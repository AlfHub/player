<!--
 ~ Copyright (c) 2011-2013 by Animatron.
 ~ All rights are reserved.
 ~
 ~ Animatron player is licensed under the MIT License, see LICENSE.
 -->

<h1>PLAYER API (@VERSION)</h1>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#sandbox">Sandbox</a></li>
<li><a href="#embedding">Embedding</a></li>
<li><a href="#embedding-player">Embedding Player</a></li>
<li><a href="#player-options">Player Options</a></li>
<li><a href="#playing-api">Playing API</a></li>
<li><a href="#loading-scenes">Loading Scenes</a></li>
<li><a href="#builder">Builder</a></li>
<li><a href="#aliases">Aliases</a></li>
<li><a href="#instantiation">Instantiation</a></li>
<li><a href="#structures">Structures</a></li>
<li><a href="#shapes">Shapes</a></li>
<li><a href="#fill--stroke">Fill &amp; Stroke</a></li>
<li><a href="#static-modification">Static Modification</a></li>
<li><a href="#bands">Bands</a></li>
<li><a href="#constants">Constants</a></li>
<li><a href="#tweens">Tweens</a></li>
<li><a href="#tween-easings">Tween Easings</a></li>
<li><a href="#time-easing">Time Easing</a></li>
<li><a href="#repeat-modes">Repeat Modes</a></li>
<li><a href="#modifiers--painters">Modifiers &amp; Painters</a></li>
<li><a href="#events">Events</a></li>
<li><a href="#time-jumps">Time Jumps</a></li>
<li><a href="#elements-interactions">Elements Interactions</a></li>
<li><a href="#live-changes">Live Changes</a></li>
<li><a href="#helpers">Helpers</a></li>
<li><a href="#scene">Scene</a></li>
<li><a href="#manual-building">Manual Building</a></li>
<li><a href="#element-structure">Element Structure</a></li>
<li><a href="#the-flow">The Flow</a></li>
<li><a href="#element-reference"><code>Element</code> reference</a></li>
<li><a href="#path-reference"><code>Path</code> reference</a></li>
<li><a href="#text-reference"><code>Text</code> reference</a></li>
<li><a href="#events--deeply">Events, Deeply</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#collisions">Collisions</a></li>
<li><a href="#importers">Importers</a></li>
<li><a href="#animatron">Animatron</a></li>
</ul>
<h2>Intro</h2>
<p>Here's the documentation on using Animatron Player to load external scenes and play them at your site. <em>And</em> it's also about building your scenes manually, but in a very easy way (we're sure you haven't seen the easier one). <em>And</em> here is also the reference on all of the player internals. The three in one. Let's start.</p>
<h2>Sandbox</h2>
<p>To get the feel on how player works, you may want to play with it at <a href="http://animatron.com/player/sandbox/sandbox.html">Sandbox</a> section. There are several examples you may observe in action there. If you want to create some animation on your own, please follow the <a href="#builder">Builder</a> section, it is the general and the single class that gives you the real power over the moving scenes.</p>
<p>You'll find a lot of checkboxes and radio buttons there, feel free to check and uncheck them. In fact, <em>Debug</em> checkbox turns player in the mode where it shows additional info on current animation for developer (such as FPS, elements' names and their registration points), <em>Interactive/Non-Interactive</em> button (it is not a checkbox, because an additional option may appear in future) enables/disables capturing mouse/keyboard events by canvas.</p>
<h2>Emdedding</h2>
<!-- FIXME: notice about a cloud -->

<h3>Embedding Player</h3>
<p>You have an unbelievable option to include a player in your own page and to load there any animation you want. You may even <a href="#builder">build your own scene</a> and show it at your site. This chapter is all you need to make this happen.</p>
<h4>1. Using IFRAME</h4>
<p>The first option is just to embed the player with some external scene to your site. You may publish one from Animatron tool (when it will be launched) and get the embed code, it will look like this:</p>
<pre><code>    &lt;iframe src="http://.../embed?4f97dd3de4b0fd8159a8df75"&gt;&lt;/iframe&gt;
</code></pre>
<p>(Customizing player style with embed code is planned) <!-- FIXME: describe --></p>
<h4>2. From Source</h4>
<p>If you'd like to <em>customize</em> things a bit more, or to have more control over the flow, or if you want to <em>import</em> some custom scene in custom format (i.e. JSON), or if you plan to <em>build</em> a scene on your own, you may want the second option: to include a player from the source.</p>
<h5>2.1. Use Player from Cloud</h5>
<p>There is always a fresh copy of player's latest version lying in S3 cloud. To use it, just follow this guide:</p>
<ul>
<li>All of the links are started with <code>http://player.animatron.com/latest/</code> for the latest version or, for concrete version, with <code>http://player.animatron.com/vX.X/</code>, where <code>X.X</code> is a version number, <code>0.9</code> for example. All files there are minified. If you want to use a not-minified version, add <code>full/</code> to the prefix.</li>
<li>There is an option to use prepared bundles, so you may inlude just one file in your page and don't bother yourself with deciding which sub-files to use and/or with adding them in proper order. Bundles are:<ol>
<li><strong>Standard</strong> (<a href="http://player.animatron.com/latest/bundle/standard.js"><code>bundle/standard.js</code></a>): just player merged with required vendor files — for quick uses of the player (when you want a very lightweight version)</li>
<li><strong>Animatron</strong> (<a href="http://player.animatron.com/latest/bundle/animatron.js"><code>bundle/animatron.js</code></a>): vendor files + player + importer from Animatron — exactly this one is used in embedded player and in the Animatron tool</li>
<li><strong>Develop</strong> (<a href="http://player.animatron.com/latest/bundle/develop.js"><code>bundle/develop.js</code></a>): vendor files + player + Builder that simplifies working with scenes in a way like JQuery simplifies working with DOM (described below in <a href="#builder">Builder</a> section) — it will work ok for developing any general (in terms of code complexity) games or script-based animations.</li>
<li><strong>Hardcore</strong> (<a href="http://player.animatron.com/latest/bundle/hardcore.js"><code>bundle/hardcore.js</code></a>): vendor files + player + Builder + additional modules (like collisions support) — intended to be used to write more complex games</li>
</ol>
</li>
<li>If you want to ensure in which files you do actually add, follow these steps:<ul>
<li>For most of the cases you need just <a href="http://player.animatron.com/latest/vendor/matrix.js"><code>vendor/matrix.js</code></a> and <a href="http://player.animatron.com/latest/player.js"><code>player.js</code></a></li>
<li>If you plan to program animation in an easy way, include <a href="http://player.animatron.com/latest/builder.js"><code>builder.js</code></a> next to them.</li>
<li>If you want to import animations from Animatron tool, include <a href="http://player.animatron.com/latest/import/animatron-importer.js"><code>import/animatron-importer.js</code></a> then. The same for other importers.</li>
<li>If you want to use some hardcore module, i.e. collisions module, include <a href="http://player.animatron.com/latest/module/collisions.js"><code>module/collisions.js</code></a> <strong>before</strong> the builder file (builder will add some features to itself depending on enabled modules), if it is used, or just in any place after player file, if it is not. The same for other modules.</li>
</ul>
</li>
</ul>
<p>See examples from Local Copy-related chapter below on how to load scenes and play them, just replace there local paths with remote ones, if you want to use them.</p>
<h5>2.2. Use Player from Local Copy</h5>
<h6>2.2.a.</h6>
<p>To do so, either clone <a href="https://github.com/Animatron/player">the repository</a> or just download the  <a href="https://raw.github.com/Animatron/player/master/src/player.js"><code>anm.player.js</code></a> and <a href="https://raw.github.com/Animatron/player/master/src/vendor/matrix.js"><code>matrix.js</code></a> <sub>(the last one is a super-tiny <a href="http://simonsarris.com/blog/471-a-transformation-class-for-canvas-to-keep-track-of-the-transformation-matrix">proxy for transformation matrix</a>, thanks to <a href="http://simonsarris.com/">Simon Sarris</a>)</sub> files in raw format. Now, include them in your HTML file:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

  &lt;head&gt;
    &lt;title&gt;My Great Page&lt;/title&gt;
 ➭  &lt;script src="./src/vendor/matrix.js" type="text/javascript"&gt;&lt;/script&gt;
 ➭  &lt;script src="./src/player.js" type="text/javascript"&gt;&lt;/script&gt;
 ➭  &lt;!-- importer or scene files go here, if one required --&gt;
 ➭  &lt;script type="text/javascript"&gt;
 ➭     function startPlaying() {
 ➭       . . . // here goes loading/playing code
 ➭     }
 ➭  &lt;/script&gt;
   &lt;/head&gt;

 ➭ &lt;body onload="startPlaying();"&gt;
     &lt;canvas id="my-canvas"&gt;&lt;/canvas&gt;
   &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>If you are importing scene in some custom format, do not forget to include the importer (see <a href="#loading-scenes">below</a> on importing scenes).</p>
<p>Then, you have a <code>Player</code> object.</p>
<h6>2.2.b.</h6>
<p>Now you may easily create a player with either of two ways below, just provide us with correct id of the canvas to attach to, and ensure that it is accessible through DOM (use <code>body.onload</code>, for example, like in previous code sample):</p>
<pre><code>// first way:
var player = createPlayer('my-canvas');
// second way:
var player = new anm.Player();
    player.init('my-canvas');
</code></pre>
<h6>2.2.c.</h6>
<p>And you may easily rule the flow by loading your own scene or importing one:</p>
<pre><code>var my_scene = ...
player.load(my_scene).play();
</code></pre>
<p>(See <a href="#loading-scenes">below</a> for more information on loading scenes, and see <a href="#builder">Builder</a> and/or <a href="#scene">Scene</a> sections for more information on scene internals)</p>
<p>You may create as many players as you want, just be sure to have enough of canvases for them.</p>
<h3>Player Options</h3>
<p>You may pass options object to player, if you want to configure it accurately. Both <code>createPlayer</code> and <code>player.init</code> may get options as second, optional, parameter.</p>
<h4>mode</h4>
<p><code>mode</code> is a way player will interact with user and how it will look like to him. You may set it this way:</p>
<pre><code>// var C = anm.C;
createPlayer('my_canvas', { 'mode': C.M_VIDEO });
</code></pre>
<p>Mode can be:</p>
<ul>
<li><code>C.M_VIDEO</code> — (default) fits for animations that do not interact with user, like movies; controls are shown, info block is shown, mouse/keybord events on shapes are not handled;</li>
<li><code>C.M_PREVIEW</code> — fits for animations/movies with showing no controls/info; both controls and info block are disabled and <em>no</em> mouse/keyboard events handled at all;</li>
<li><code>C.M_DYNAMIC</code> — fits for games and interactive animations; both controls and info block are disabled and all mouse/keyboard events are handled on the objects expecting them;</li>
</ul>
<p>There are a bit more variants for <code>mode</code> and you may mix them with single pipe (<code>|</code>), like here:</p>
<pre><code>createPlayer('my_canvas', { 'mode': C.M_CONTROLS_ENABLED | C.M_INFO_DISABLED | C.M_HANDLE_EVENTS });
</code></pre>
<p>But they are intended for rare use and we hope you'll be fine with three predefined ones.</p>
<p>You may also do this with <code>var player = createPlayer(...); player.mode = C.M_...;</code>, it has the same effect.</p>
<p><strong>NB</strong>: <code>C.M_VIDEO</code>, <code>C.M_PREVIEW</code> and <code>C.M_DYNAMIC</code> are the precalculated mixes of these "precise" options.</p>
<h4>debug</h4>
<p>If you want to see the FPS rate, shapes origin points, names of the shapes, the traces of their translate operations, set <code>debug</code> to <code>true</code>. You may also do this with <code>var player = createPlayer(...); player.debug = true;</code>, it has the same effect.</p>
<h4>zoom</h4>
<p>To zoom an animation besides the canvas size (normally all animations fit the canvas), you may use <code>zoom</code> option. You may also do this with <code>var player = createPlayer(...); player.zoom = ...;</code>, it has the same effect.</p>
<h4>meta</h4>
<p><code>meta</code> block provides the information about the animation author, title and copyright. However, if you load the Scene with <a href="#importers">Importer</a>, it will be overriden from there (it also is useful if you associate one separate scene with one separate player).</p>
<h4>anim</h4>
<p><code>anim</code> (shorten from 'animation') is the tuning of the canvas size, player background color and the default duration of the scene (it also is useful if you associate one separate scene with one separate player).</p>
<p><strong>NB:</strong> If canvas element where player attached to has <code>width</code> and <code>height</code> attributes set, then they have a higher priority over configuration when loading a scene. So if you want player to update its size dynamically from options or animation configuration, ensure to remove these attributes from element.</p>
<h4>Example</h4>
<p>The complete options object, filled with default values, looks like this (any option is optional, pardon the tautology: you may even pass an empty object, if you want):</p>
<pre><code>{ "debug": false, // in debug mode, FPS, shapes names and moving paths are shown
  "muteErrors": false, // supress errors while playing or not
  "mode": C.M_VIDEO, // player mode, may also be C.M_PREVIEW or C.M_DYNAMIC
  "zoom": 1.0, // zoom ratio for animation.
  "repeat": false, // repeat the scene again when it finished to play or not
  "meta": { "title": "Default", // meta data is injected in info block
            "author": "Anonymous",
            "copyright": "© NaN",
            "version": -1.0,
            "description":
                    "Default project description",
            [ "modified": 12272727271871 ] }, // in milliseconds, not used currently
  "anim": { ["fps": 30,] // time coefficient, not used currently
            "width": 400, // animation width, player will be resized if required
            "height": 250, // animation height, player will be resized if required
            "bgfill": { color: "#fff" }, // canvas background color
            "duration": 10 } } // duration may be auto-calculated, but if provided,
                              // this value will be taken
</code></pre>
<h3>Playing API</h3>
<blockquote>
<p>♦ <code>createPlayer(canvasId: String[, options: Object])</code></p>
<p>♦ <code>load(scene: Any[, importer: Importer])</code></p>
<p>♦ <code>play([time: Float][, speed: Float][, stopAfter: Float])</code></p>
<p>♦ <code>pause()</code></p>
<p>♦ <code>stop()</code></p>
<p>♦ <code>onerror(callback: Function(evt: Event))</code></p>
</blockquote>
<h3>Loading Scenes</h3>
<p>Player works with Scenes and plays any Scene easily, if this Scene is of those:</p>
<ul>
<li>Any scene in any JS-compatible format (String, JavaScript Array or Object, a Big Number), if you have an <a href="#importers"><code>Importer</code></a> for it;</li>
<li>An URL to JSON, the one we may load with AJAX; the returned JSON may be in any format, just ensure that you have a corresponding <a href="#importers"><code>Importer</code></a> for it;</li>
<li><a href="#builder"><code>Builder</code></a> instance, see its reference below;</li>
<li><a href="#scene"><code>Scene</code></a> instance, see its reference below;</li>
<li>An array of <code>Clip</code>s or <code>Elements</code>, they are also described in <a href="#scene">Scene section</a>;</li>
</ul>
<p>Loading and playing a scene requires a scene object (you may load it from external file or create in place) and an instance of <a href="#importers">Importer</a>, if this scene is in unknown format.</p>
<h4>a. from any object (with Importer)</h4>
<p>Just include the <a href="#importers">Importer</a> in the head section of your HTML file. If you store your scene in a file, then also include the scene file:</p>
<p><code>my_scene.js</code>:</p>
<pre><code>var my_scene = {
    . . .
};
</code></pre>
<p><code>foo.html</code>:</p>
<pre><code>. . .
&lt;!-- player files --&gt;
&lt;script src="./my_importer.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="./my_scene.js" type="text/javascript"&gt;&lt;/script&gt;
. . .
</code></pre>
<p>Loading code:</p>
<pre><code>createPlayer('my_canvas').load(my_scene, new MyImporter())
                         .play();
</code></pre>
<p><strong>Note</strong>: You may re-use one importer to load several scenes.</p>
<h4>b. by URL</h4>
<p>You don't need to include the scene, since it will be loaded with AJAX, just ensure that URL returns true JSON format, that this location is accessible for your client and do not forget to include importer:</p>
<pre><code>&lt;!-- player files --&gt;
&lt;script src="./my_importer.js" type="text/javascript"&gt;&lt;/script&gt;
</code></pre>
<p>Loading code:</p>
<pre><code>createPlayer('my_canvas')
        .load('http://acme.com/my_scene.json', new MyImporter())
        .play();
</code></pre>
<h4>c. building with Builder</h4>
<p><a href="#builder"><code>Builder</code></a> is an easy way to build animations (scenes) in JQuery-like style. So you may pass the created scene to the player and have fun. Do not forget to include <code>Builder</code>, since it is not the required player file. You may get it in raw format the same way as player files: <a href="https://raw.github.com/Animatron/player/master/src/builder.js"><code>builder.js</code></a>.</p>
<pre><code>&lt;!-- player files --&gt;
&lt;script src="./src/builder.js" type="text/javascript"&gt;&lt;/script&gt;
</code></pre>
<p>Loading code:</p>
<pre><code>var scene = new Builder('blue rect').rect([100, 100], [40, 60])
                                    .fill('#00f')
                                    .stroke('#f00', 2)
                                    .rotate([0, 5], [0, Math.PI / 2]);
createPlayer('my_canvas').load(scene).play();
</code></pre>
<p><strong>Note</strong>: You may want to create an alias for builder, so it will look even more in JQuery-style (and in that version it auto-caches the instances):</p>
<pre><code>var b = Builder._$; // instead of "b", you may even name it "_" or "$",
                    // if it will not clash with JQuery or some other library
                    // on the page
var scene = b().add(
                   b().rect(. . .)
              ).add(
                   b().circle(. . .)
              ).add(
                   b('custom clip').. . .
              );
</code></pre>
<p>More information is in <a href="#builder">Builder</a> section.</p>
<h4>d. creating Scene instance</h4>
<p>You may build a <a href="#scene"><code>Scene</code></a> instance manually, with no usage of <code>Builder</code>, if you want (but <code>Builder</code> is really-really tiny, why? :) ). So you don't need to include anything additional to player files (except the case when you build your scene in external file, so you'll need to include this very file):</p>
<pre><code>var C = anm.C;
var scene = new anm.Scene();
var elem = new anm.Element();
elem.xdata.path = new anm.Path('M36 35 L35 70 L90 70 L50 20 Z',
                  { width: 2, color: '#300' },
                  { color: '#f00' });
elem.addTween({
    type: C.T_ROTATE,
    band: [0, 3],
    data: [Math.PI / 6, 0]
});
elem.addTween({
    type: C.T_TRANSLATE,
    band: [0, 3],
    data: anm.Path.parse('M-100 -100 L100 100 Z')
});
elem.addTween({
    type: C.T_ALPHA,
    band: [1.5, 3],
    data: [1, 0]
});
scene.add(elem);

createPlayer('my_canvas').load(scene).play();
</code></pre>
<h4>e. from array of Clips</h4>
<p><code>Clip</code> is the nickname for <code>Element</code> in our player, so there is no difference between them, just construct some elements and add them as array (if fact, it is not the preferred method, it is just provided for the real conformists):</p>
<pre><code>var first = new anm.Element();
first.addPainter(function(ctx) {
  ctx.save();
  ctx.strokeStyle = '#f00';
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(50, 50);
  ctx.stroke();
  ctx.closePath();
  ctx.restore();
});
var second = new anm.Clip();
second.addPainter(function(ctx) {
  ctx.save();
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(50, 30);
  ctx.lineTo(100, 100);
  ctx.stroke();
  ctx.closePath();
  ctx.restore();
});

createPlayer('my_canvas').load([first, second]).play();
</code></pre>
<h2>Builder</h2>
<p><code>Builder</code> is the best method for accelerated scene building. It is based on JQuery-like concept (the <em>State Monad</em>, if it says something to you), so the instance of <code>Builder</code> is the one single object you'll need to do anything you want. If you are not JQuery lover, name it "just useful chaining".</p>
<p>Below is the reference for all of the <code>Builder</code> possibilities.</p>
<p>(Don't forget to include its file in the page: <code>src/builder.js</code>, as desribed above in <strong>Loading Scenes / c. building with Builder</strong>)</p>
<p>Let's give an example: this is how the typical complicated scene looks when constructed with <code>Builder</code>:</p>
<pre><code>var b = Builder._$; // quick alias
b('scene').band([0, 20])
          .add(b('red-rect').fill('#f00')
                            .rect([30, 30], [20, 40])
                            .rotate([0, 10], [0, Math.PI / 2]))
          .add(b('bendie').image('./bender.png')
                          .band([10, 15])
                          .alpha([0, 1], [0, 1])
                          .trans([1, 5], [[0, 0], [20, 20]])
                          .bounce());
</code></pre>
<p>You may load any animation created with <code>Builder</code> directly to player, so this code, for example, will nicely work:</p>
<pre><code>createPlayer('my-canvas').load(b().rect([0, 20], 40)).play();
</code></pre>
<p>By the way, order of operations over the <code>Builder</code> instance has <sub>almost</sub> absolutely no matter for the result, it is only the matter of easy-reading your own code. To be honest, there are several minor exceptions, and if they will be important, we'll mention them individually in the corresponding section. Until that, feel free to mess things while it fits you and your friends.</p>
<h4>Sandbox</h4>
<p><a href="http://animatron.com/player/sandbox/sandbox.html">Sandbox</a> also works with the examples constructed with <code>Builder</code> (among with manually created <a href="#scene">Scene</a> instances), it just uses the value returned from user code as the scene to load into player. So if you want to see any example from this document in action, just copy-paste it to Sandbox page and add the last line returning any <code>b</code> instance to the player, like <code>return scene;</code> or <code>return child;</code> or <code>return b('wrapper').add(child).add(child);</code>.</p>
<h3>Aliases</h3>
<p>It is too long to type <code>new Builder(. . .)</code> all the time when you need a new instance of <code>Builder</code>, so it is recommended to make an alias for it. Any you want, even "<code>_</code>" (underscore), just ensure that it not clashes with some existing variable. So, if you are using JQuery on your page, please don't use "<code>$</code>" alias, or wrap your code with anonymous function. We think the best one is "<code>b</code>".</p>
<pre><code>var b = Builder._$; // `._$` points to the function that calls
                    // "new Builder(arguments)" or takes one from cache
</code></pre>
<p>Among with <code>b</code> (or your variant), you may need some alias to access player constants (in fact, they are only used for easings, so it is really optional, if you don't use any of these). The single object that contains player constants is <code>anm.C</code>, so you may append some <code>C</code> variable to your code, if you want to access it faster:</p>
<pre><code>var C = anm.C;
</code></pre>
<p>The last optional variant is to make alias for a <code>Builder</code> class itself (not a constructor), because you may find useful to use its static methods (they allow to quickly create paths from points and gradients and make other complicated things easier). Here's the way:</p>
<pre><code>var B = Builder;
</code></pre>
<p>Now you may write something like this:</p>
<pre><code>b().rect([20, 20], [10, 30])
   .fill(B.grad(['#f00', '#00f']))
   .alpha([0, 7], [1, 0], C.E_CINOUT); // Cubic In-Out Easing
</code></pre>
<h3>Instantiation</h3>
<blockquote>
<p>♦ <code>Builder % ([String | Element | Builder])</code></p>
</blockquote>
<p><code>Builder</code> constructor takes either of:</p>
<ul>
<li>Nothing — creates an empty element and keeps it inside to work with it during next calls;</li>
<li><code>String</code> — creates an element with given name and keeps it inside to work with it during next calls;</li>
<li><code>Element</code> — keeps the given element inside to work with it during next calls;</li>
<li><code>Builder</code> — creates a clone of the given <code>Builder</code>, so next changes for the last
              one does not apply to created one and vise versa;</li>
</ul>
<p>Every <code>Builder</code> instance have five public properties: <code>v</code>, <code>n</code>, <code>x</code> and <code>f</code>, <code>s</code>. Factually, you will need only the <code>v</code> one: it points to the <code>Element</code> instance <code>Builder</code> works with. <code>f</code> and <code>s</code> are current fill and stroke, <code>n</code> is the name of element, and <code>x</code> is element's <code>xdata</code> (see <code>xdata</code> explanation in <a href="#element">Element</a> reference section, but you'll for sure don't need it if you use <code>Builder</code> to build scenes):</p>
<pre><code>var b = Builder._$; // we will omit it in next snippets

// Nothing
var b_noname = b();
console.log(b_noname.v instanceof anm.Element); // true
console.log(b_noname.n === ''); // true

// String
var b_named = b('shape');
console.log(b_named.v instanceof anm.Element); // true
console.log(b_named.n === 'shape'); // true

// Element
var elem = new anm.Element();
elem.name = 'foo';
var b_elem = b(elem);
elem.name = 'bar';
console.log(b_elem.v instanceof anm.Element); // true
console.log(b_elem.n === 'foo'); // true

// Builder
var b_src = b('src');
var b_dst = b(b_src);
console.log(b_src.n === b_dst.n); // true
console.log(b_src.v === b_dst.v); // false (they're different instances)
</code></pre>
<!-- TODO: image of the process described in paragraph below -->

<p>When you have an instance of <code>Builder</code>, it is just the prepared state of some <a href="#shapes">shape</a>: path, image, or text. It becomes dynamic when you add <a href="#tweens">tweens</a> and/or <a href="#modifiers">modifiers</a> to it. But it is still just prepared dynamic condition — to make it play, you need to pass (load) it into player. This is when system appends all required functionality to it, allows it to act. The same is true for <a href="#element-reference">Element</a>. Of course, you don't need to add every Builder/Element, it happens automatically for the complete scene tree when you load it into player. See <a href="#scene">Scene</a> section for more information on this, if you want.</p>
<p><strong>NB:</strong> Cloning (the last one in the list) is a very tasty feature, but you need to be very accurate with it. Among with element internals it deeply-clones its children array. So, if you create a recursive scene, be accurate with things like this:</p>
<pre><code>var c = b().circle([0, 0], 20);
// var scene = c;
for (var i = 0; i &lt; 30; i++) {
    c.add(b(c).move([10, 10])); // will add 30x30 children to tree
} // this will end up with hanging player

// safe way with nesting:
var c = b().circle([0, 0], 20);
// var scene = c;
for (var i = 0; i &lt; 30; i++) {
    c.add(c = b(c).move([10, 10])); // will nest every new child a level below
}

// safe way with 30 children:
var c = b().circle([0, 0], 20);
// var scene = c;
var clone = b(c);
for (var i = 0; i &lt; 30; i++) {
    c.add(b(clone).move([i*10, i*10])); // add new clone, all children are on the same level
}
</code></pre>
<p><strong>NB:</strong> <code>Builder._$(...)</code>/<code>b(...)</code> function differs from <code>new Builder(...)</code> call — if <code>Element</code> is passed to the first one, it checks if there was one created for this element already, and instantiates <em>new</em> <code>Builder</code> only if not, else it returns the cached one. Cloning is cloning however, so if there is a <code>Builder</code> passed, it honestly creates a clone in both cases.</p>
<h3>Structures</h3>
<p>Thanks to <code>Builder</code> mechanics, you may build scenes with nesting level of any depth. Just put one element inside another, once again with other one, and keep adding and adding, and wow — you accidentally have the tree of elements right in your hands:</p>
<blockquote>
<p>♦ <code>builder.add % (what: Element | Builder) =&gt; Builder</code></p>
</blockquote>
<p>Any <code>Element</code> or <code>Builder</code> instances are allowed to add; by the way, you may treat the top (root) element as the scene:</p>
<pre><code>var scene = b('scene').band([0, 3]);
var cols_count = 26;
var rows_count = 16;
var column;
for (var i = 0; i &lt; cols_count; i++) {
    scene.add(column = b('column-' + i));
    // you may keep adding sub-child elements even when
    // you've already appended a child to your scene,
    // it is only important to do it before
    // calling player.load for this scene
    for (var j = 0; j &lt; rows_count; j++) {
        column.add(b('elm-' + j)
                   .rect([i*15, j*15], 10)
                   .rotate([0, 3], [0, Math.PI * 2]));
    }
    var offset = (cols_count / (i+1))*6;
    column.band([0, 1.5])
          .trans([0, 1.5], [[0, 0],
                            [offset, offset]])
          .bounce();
}
scene.move([10, 10]);
</code></pre>
<p>So, to resume: any element may be a parent one, it may have any number of children (it only may affect performance, but we keep working to enhance these limits), you may (but not required to) draw something with a parent element, and then with its children, and they will be drawn one over another. All of the values (like points, angles, time bands) of some element are relative to the parent element, if it exist. If it not, they are relative to global things. If you change the parent, values stay the same, but now they are relative to a new parent.</p>
<p>Just add something like <code>.circle([0, 0], 50)</code> to the <code>column</code> element in example above, and you'll see how it works. (It will shift the location of columns to be in center of circle, so you may want to change <code>scene.move([10, 10])</code> to <code>scene.move([60, 60])</code>, like the radius of circle + padding of 10, and the animation will be back in bounds).</p>
<blockquote>
<p>♦ <code>builder.remove % (what: Element | Builder) =&gt; Builder</code></p>
</blockquote>
<p>You may permanently remove some element from scene if you want. Just call <code>remove()</code> method at any of its parents. But it is a slow operation (the deeper element distance from callee is, the operation slower), please just use it if you really know what you want to do. If you want to disable an element (completely), just call <a href="#elements-interactions"><code>b().disable()</code></a>. Also, as for <code>disable()</code>, please note that removing element stops all its calculations, so there is no chance for logic or something to be called when it was removed, even if its band is infinite.</p>
<h3>Shapes</h3>
<p>If you will dive into internals of player API (<a href="#scene">Scene</a> section), you will notice that any element may represent:</p>
<ul>
<li>Nothing — so nothing will be drawn with it (however, you may affect children elements without even drawing something);</li>
<li>Path — any path, including rectangles, circles, polygons or any of your custom-shaped-curves;</li>
<li>Image — just give us just an accessible URL, soon we will even support splitting the image and showing it's parts in different acts of the scene;</li>
<li>Text — any text, this one is separate from "Path" concept, because it has a lot of own manners;</li>
</ul>
<p>In fact, you may use several of those in one element, they will be drawn correctly, but why you'd need it? So please, treat every single element as only one of these.</p>
<p>So, how'd you create them? Let's start from two basic shapes, rectangle and circle. If you test the examples, they will be drawn with default fill and stroke, so you'll see them for sure.</p>
<h4>rect</h4>
<blockquote>
<p>♦ <code>builder.rect % (pt: Array[2,Integer], rect: Array[2,Integer] | Integer) =&gt; Builder</code></p>
</blockquote>
<p>You may easily create a rectangle by specifying its location and its width/height this way:</p>
<pre><code>b().rect([ 50, 50 ], // its center will pe placed at (50,50) of parent
         [ 100, 50 ]); // it will have 100-unit width and 50-unit height
</code></pre>
<p>If you want to get rect with equal width and height, just give one number as second argument:</p>
<pre><code>b().rect([ 50, 60 ], // its center will pe placed at (50,60) of parent
         57);        // it will have 57-unit width and 57-unit height
</code></pre>
<h4>circle</h4>
<blockquote>
<p>♦ <code>builder.circle % (pt: Array[2,Integer], radius: Float) =&gt; Builder</code></p>
</blockquote>
<p>To create circle, specify its location and radius, and that's all:</p>
<pre><code>b().circle([ 40, 35 ], // its center will pe placed at (40,35) of parent
           8); // it will have 8-unit radius
</code></pre>
<p><strong>NB:</strong> Circle is not a Path, unlike rectangle, if you want the truth — it is created with <a href="#painters">Painter</a> and draws a corresponding arc, but from a user point of view, we think, it best fits this disguise.</p>
<h4>path</h4>
<blockquote>
<p>♦ <code>builder.path % (path: Array | String | Path, [pt: Array[2,Integer]]) =&gt; Builder</code></p>
</blockquote>
<p>Now, if you want some custom shape, you may have it with the similarly easy way
(may be just a bit complex, though :) ). There's two ways to do it:</p>
<ol>
<li>
<p>If you know &amp; like SVG, you'll like to pass the string here.</p>
<pre><code>b().path('M0 0 L50 50 C105 260 260 260 380 40 Z');
</code></pre>
<p>The string format currently differs from 'standard' SVG path description,
 it only supports <code>M</code>|<code>L</code>|<code>C</code> commands, only in upper-case, and we don't
 think it will be required to extend it, may be only adding <code>Q</code>-quad segment.</p>
</li>
<li>
<p>If not, we have an even simpler way for you: you just pass the array of points and we create the path:</p>
<pre><code>b().path([ [ 0, 0 ], [ 50, 50 ],
           [ 80, 80 ], [ 120, 100 ] ])
</code></pre>
<p>This path will 'turn' at each of four points and end at (120, 100). If you add a last point of (0, 0) (equal to start point), it will be the closed path.</p>
<p>This way even accepts curve segments. If you specify six coordinates instead of two, it will treat that element as bezier-curve points (see <a href="http://www.html5canvastutorials.com/tutorials/html5-canvas-bezier-curves/"><code>bezierCurveTo</code></a> to know what means each of points). It works like this:</p>
<pre><code> b().path([ [ 0, 0 ], [ 50, 50 ],
            [ 105, 260, 260, 260, 380, 40 ],
            [ 0, 0 ] ]);
</code></pre>
<p>The second one works even faster, because it don't parses a string.</p>
</li>
</ol>
<p>The optional <code>pt</code> argument specifies the future position of the path in parent space and defaults to <code>[0, 0]</code>.</p>
<p>You may want to draw a shape by yourself, if it is someway more complex than a path or it is hard to describe it with a path (ellipse, for example). Then you may use <a href="#painters">Painters</a> and use a canvas-context commands direclty.</p>
<ol>
<li>
<p>If you want to cache some path and pass it several times to different shapes, you may use <code>B.path</code> helper (remember static methods from <a href="#aliases">Aliases</a> chapter?) to create it from points array or <code>anm.Path.parse()</code> static method to parse it from string:</p>
<p>var my_path_one = B.path([[ 0, 0 ], [ 50, 50 ], [ 30, 60 ], [ 0, 0 ]]);
var my_path_two = anm.Path.parse('M0 0 L50 50 L30 60 L0 0 Z');
for (var i = 0; i &lt; 20; i++) {
   scene.add(b().path(my_path_one).move([i<em>10, i</em>10]));
   scene.add(b().path(my_path_two).move([i<em>10+5, i</em>10+5]));
}</p>
</li>
</ol>
<p><strong>NB:</strong> All builder methods who work with paths do accept all these three ways of specifying the path.</p>
<p><strong>NB:</strong> One important thing to inform you: every path passed to this function will be normalized. It means that its points will be recalculated to be relative to its center, so if you'll make a shift of 50 by x for each point before passing it to <code>path()</code>, you will surely lose the effect: change registration point with <a href="#static-modification"><code>reg()</code></a> method after the path creation for this purpose. The illustration:</p>
<pre><code>// all these calls will lead to the paths with absolutely equal points
b().path([ [ 50, 50 ], [ 100, 100 ] ]);
b().path([ [ 0, 0 ], [ 50, 50 ] ]);
b().path([ [ -25, -25 ], [ 25, 25 ] ]); // this one will
                                        // not even change
// use this method to change the registration point
b().path([ [ -25, -25 ], [ 25, 25 ] ])
   .reg([ -75, -75 ]) // relative to [ 0, 0 ]
</code></pre>
<h4>image</h4>
<blockquote>
<p>♦ <code>&gt; builder.image % (pt: Array[2,Integer], src: String) =&gt; Builder</code></p>
</blockquote>
<p>To load an image into player, just provide its URL and the point where you want it to be located at first. Please ensure that this image is accessible for the player client, this restriction is the same restriction as for <code>drawImage</code> of HTML5 canvas. And supported formats are the same. And, also, please ensure you have the copyrights for the image, it will be your problem if you violate them.</p>
<pre><code>b().image([ 30, 18 ], // its center will pe placed at (30,18)
          'http://'); // it will have 8-unit radius
</code></pre>
<p><strong>NB.</strong> We also have plans to support sprites soon, stay tuned.</p>
<h4>text</h4>
<blockquote>
<p>♦ <code>&gt; builder.text % (pt: Array[2,Integer], lines: String | Array[String] | Text, [size: Float], [face: String | Array[String]]) =&gt; Builder</code></p>
</blockquote>
<p>To place a text somewhere, specify its location and the characters line. Optionally, you may pass the font and size. Lines may be specified with array instead of string, then they will be drawn one below the other, like in text.</p>
<pre><code>b().text([ 60, 40 ], 'My text');
b().text([ 100, 100 ], My text', 12);
b().text([ 100, 100 ], My text', 10, 'sans-serif').nostroke();
b().text([ 120, 10 ], ['This One', 'Above', 'The Other'])
   .stroke('red').nofill();
</code></pre>
<h3>Fill &amp; Stroke</h3>
<p>Any path or text are represented with default fill (gray) and stroke (black, 1-unit width), until you haven't specified another. For sure, you would like to override these depressive colors and, of course, there is a way to do it.</p>
<blockquote>
<p>♦ <code>&gt; builder.fill % (color: String | Gradient) =&gt; Builder</code>
♦ <code>&gt; builder.stroke % (color: String | Gradient, [width: Float, cap: C.PC_*, join: C.PC_*]) =&gt; Builder</code></p>
</blockquote>
<p>The color format is either CSS-like (<code>#ff0060</code>, <code>#a69</code> <code>blue</code>) or <code>RGB/HSL[A]</code>-string (<code>rgb(20, 20, 90)</code>, <code>rgba(20, 20, 90, .5)</code>, <code>hsla(70, 30, 120, .7)</code>), similar to canvas specifications for colors. If you calculate the color in place, you may find useful <code>B.rgb()</code> and <code>B.hsv()</code> methods, they take numeric values and concatenate them into properly-formatted color-string.</p>
<pre><code>b().fill('#f00');
b().fill('black');
b().fill('rgba(20, 40, 19, 0.3)');
b().fill(B.rgb(20, 20, 70));
b().fill(B.rgb(25, 40, 70, .5));
b().fill(B.frgb(0, 0, .5));
b().stroke(B.frgb(.5, .8, .9, .5));
b().stroke('#c60000');
b().stroke(B.hsv(270, .3, .9), 7);
b().stroke(B.fhsv(.9, 0, .6, 1), 7);
</code></pre>
<p>Color values for <code>rgb()</code> parameters are laying between <code>[0..255]</code>, alpha is a fraction of 1, <code>[0..1]</code>. For <code>hsv()</code>, hue is <code>[0, 360]</code>, because it is an angle, and all other values, including alpha, are <code>[0..1]</code>. There are also <code>frgb()</code> and <code>fhsv()</code> functions, where all values are <code>[0..1]</code>.</p>
<p>And, you may use gradients here! It is not so easy to create canvas-compatible gradient manually, so there is also a helper for it:</p>
<pre><code>// linear gradient
b().fill(B.lgrad([ [ -35, -35 ], [ 35, 35 ] ], // direction of the gradient
                 [ [ 0, 'black' ], // any number of color stops
                   [ 1, 'blue'  ] ]));
// radial gradient
b().fill(B.rgrad([ [ 0, 0 ], [ 15, 5 ] ], // direction of the gradient
                 [ 0, 35 ], // inner and outer bounding circles radius
                 [ [ 0, 'black' ], // any number of color stops
                   [ .5, 'yellow' ],
                   [ 1, 'blue' ] ]);
</code></pre>
<p>Note that gradient direction points are specified relatively to origin point of the shape.</p>
<p>Besides the width (which is 1 by default), <code>stroke</code> also takes two optional parameters named <code>cap</code> and <code>join</code>. They describe the way successive strokes are connected in the paths: possible values for these will be described in <a href="#constants">Constants</a> section.</p>
<p>If you don't like the default stroke or fill, you'd probably want to turn one off. There are <code>nofill()</code> and <code>nostroke()</code> methods that may help with this:</p>
<blockquote>
<p>♦ <code>builder.nofill % () =&gt; Builder</code></p>
<p>♦ <code>builder.nostoke % () =&gt; Builder</code></p>
</blockquote>
<h3>Static Modification</h3>
<p>As in difference with <a href="#tweens">Tweens</a>, sometimes you need to "correct" the state of some shape to be applied through all the scene. It makes sense when you are not able to set wanted value with the shape creation function. There's only three such methods, they correct the shape inner state: other things may be easily done with <a href="#modifiers--painters">Modifiers</a>.</p>
<blockquote>
<p>♦ <code>builder.reg % (pt: Array[2,Integer]) =&gt; Builder</code></p>
</blockquote>
<p>This method changes the registration point position of the shape, this point affects tweens, so the rotation will be performed around this point, translation will be shifted with this point and so on. This point needs to be specified relative to the center of the shape. Use <a href="#player-options">'debug' mode</a> of the player to see the registrations points of the shapes.</p>
<!-- TODO: regAt & its constants (not works for circle) -->

<pre><code>b().circle([ 20, 20 ], 60).reg([ -10, -10 ]);
</code></pre>
<blockquote>
<p>♦ <code>builder.move % (pt: Array[2,Integer]) =&gt; Builder</code></p>
</blockquote>
<p>Moving changes the position of the element in its parent coordinate system. It is a bit different thing to the point of the shape, because setting point also recalculates the path to be centered at this point and move does not. Also it is useful if you want to move a group of elements when they were already created.</p>
<pre><code>b().rect([ 10, 10 ], 60).move([ 40, 40 ]);
</code></pre>
<blockquote>
<p>♦ <code>builder.zoom % (val: Array[2,Float]) =&gt; Builder</code></p>
</blockquote>
<p>Zooming will recalculate the path points to be positioned with the specified zoom (so it won't work for circle). There's no 'undo', you'll need to recalculate to inverted zoom to return everything back.</p>
<pre><code>b().rect([ 10, 10 ], 60).zoom([ .5, 2 ]);
</code></pre>
<h3>Bands</h3>
<p>When you costruct a complex animation scene, you need to set time regions where the particular element stays visible. These regions are often called 'bands'. By default, for every shape the band is <code>[0, 10]</code>. It means that this shape is visible from 0 seconds to 10 seconds of the parent element's band, or the global time, if there's no parent specified.</p>
<blockquote>
<p>♦ <code>builder.band % (band: Array[2,Float]) =&gt; Builder</code></p>
</blockquote>
<p>This way you may wrap three elements and show them one by one:</p>
<pre><code>// seconds in comments are global-time seconds;
b('root')
  .band([2, 16])
  .circle([0, 0], 16) // this circle will be visible
                        // from 2 sec to 16 sec
  .move([40, 40])
  .add(b('child') // no band specified, so its band
                  // is [0, 10] -&gt; 2 sec to 12 sec
        .add(b('2-4').band([0, 2]) // 2 sec to 4 sec
                     .circle([60, 20], 20))
        .add(b('3-6').band([1, 4]) // 3 sec to 6 sec
                     .circle([60, 40], 20))
        .add(b('6-9').band([4, 7]) // 6 sec to 9 sec
                     .circle([80, 60], 20))
        .add(b('8-12').band([6, 10]) // 8 sec to 12 sec
                     .circle([100, 100], 20)));
</code></pre>
<p>Time values may be fractional, so the band <code>[1.5, 3.7]</code> is totally correct.</p>
<p>Among with that, setting a band affects the <a href="#repeat-modes">Repeat Mode</a> of the shape animation within the parent's time space.</p>
<h3>Constants</h3>
<!-- TODO: move to the top ? -->

<p>Some of the functions described below (such as tweens, easings, repeat modes and events managers in <a href="#builder">Builder</a> and a lot of methods of <a href="#element">Element</a>) use some string value determining the type of action to perform as a parameter. It is recommended to use constants for these cases, because string values may change with time, but constants will not. All constants are defined in <code>anm.C</code> object, so it will also be useful for you to you use <code>C</code> <a href="#aliases">alias</a> for <code>anm.C</code>, then any constant name will look for you like <code>C.&lt;constant-type&gt;_&lt;constant-name&gt;</code>. The places where constants may be used are also marked with the same pattern. The below is the list of the possible constants grouped by type.</p>
<ol>
<li>Player state <code>C.*</code> /read-only, <code>player.state</code>/<ul>
<li><code>C.NOTHING</code> — nothing loaded into player</li>
<li><code>C.STOPPED</code> — playing stopped</li>
<li><code>C.PLAYING</code> — playing</li>
<li><code>C.PAUSED</code> — playing paused</li>
</ul>
</li>
<li><a href="#mode">Player mode</a> <code>C.M_*</code> /<code>player.mode</code>/<ul>
<li>Grouped<ul>
<li><code>C.M_PREVIEW</code> - Preview Mode, controls and interaction disabled</li>
<li><code>C.M_DYNAMIC</code> - Dynamic Mode, controls disabled and user interaction enabled</li>
<li><code>C.M_VIDEO</code> - Video Mode, controls enabled, but interaction disabled</li>
</ul>
</li>
<li>Separate<ul>
<li><code>C.M_HANDLE_EVENTS</code> | <code>C.M_DO_NOT_HANDLE_EVENTS</code> — Handling events (interaction) enabled/disabled</li>
<li><code>C.M_CONTROLS_ENABLED</code> | <code>C.M_CONTROLS_DISABLED</code> — Controls enabled/disabled</li>
<li><code>C.M_INFO_ENABLED</code> | <code>C.M_INFO_DISABLED</code> — Info block enabled/disabled</li>
</ul>
</li>
</ul>
</li>
<li><a href="#events">Events</a> <code>C.S_*</code>, <code>C.X_*</code>, <code>C.XT_*</code><ul>
<li>Player<ul>
<li><code>C.S_PLAY</code> — Playing started</li>
<li><code>C.S_PAUSE</code> — Playing paused</li>
<li><code>C.S_STOP</code> — Playing stopped</li>
<li><code>C.S_LOAD</code> — Scene loaded</li>
<li><code>C.S_REPEAT</code> — Auto-repeat was called</li>
<li><code>C.S_ERROR</code> — Error happened</li>
</ul>
</li>
<li>Element<ul>
<li>Mouse <code>C.X_M*</code>, <code>C.XT_MOUSE</code><ul>
<li><code>C.X_MCLICK</code> — Mouse Click event</li>
<li><code>C.X_MDCLICK</code> — Mouse Double-Click event</li>
<li><code>C.X_MMOVE</code> — Mouse Move event</li>
<li><code>C.X_MUP</code> — Mouse Up event</li>
<li><code>C.X_MDOWN</code> — Mouse Down event</li>
<li><code>C.X_MOVER</code> — Mouse Over event</li>
<li><code>C.X_MOUT</code> — Mouse Out event</li>
</ul>
</li>
<li>Keyboard <code>C.X_K*</code>, <code>C.XT_KEYBOARD</code><ul>
<li><code>C.X_KPRESS</code> — Key Press event</li>
<li><code>C.X_KUP</code> — Key Up event</li>
<li><code>C.X_KDOWN</code> — Key Down event</li>
</ul>
</li>
<li><code>C.X_DRAW</code> — Draw event</li>
</ul>
</li>
</ul>
</li>
<li><a href="#repeat-modes">Element Repeat mode</a> <code>C.R_*</code><ul>
<li><code>C.R_ONCE</code> — play once</li>
<li><code>C.R_STAY</code> — play once and stay</li>
<li><code>C.R_REPEAT</code> — repeat playing</li>
<li><code>C.R_BOUNCE</code> — play forward-backward and repeat</li>
</ul>
</li>
<li><a href="#tweens">Tweens</a> <code>C.T_*</code><ul>
<li><code>C.T_TRANSLATE</code> — Translate Tween</li>
<li><code>C.T_SCALE</code> — Scale Tween</li>
<li><code>C.T_ROTATE</code> — Rotate Tween</li>
<li><code>C.T_ROT_TO_PATH</code> — Rotate-To-Path Tween</li>
<li><code>C.T_ALPHA</code> — Alpha Tween</li>
</ul>
</li>
<li><a href="#tween-easings">Easings</a> <code>C.E_*</code><ul>
<li>Curve-based Easings<ul>
<li><code>C.E_DEF</code> — Default easing</li>
<li><code>C.E_IN</code> | <code>C.E_OUT</code> | <code>C.E_INOUT</code> — Standard In, Out and In/Out easings</li>
<li><code>C.E_SIN</code> | <code>C.E_SOUT</code> | <code>C.E_SINOUT</code> — Sine In, Out and In/Out easings</li>
<li><code>C.E_QIN</code> | <code>C.E_QOUT</code> | <code>C.E_QINOUT</code> — Quad In, Out and In/Out easings</li>
<li><code>C.E_CIN</code> | <code>C.E_COUT</code> | <code>C.E_CINOUT</code> — Cubic In, Out and In/Out easings</li>
<li><code>C.E_QTIN</code> | <code>C.E_QTOUT</code> | <code>C.E_QTINOUT</code> — Quart In, Out and In/Out easings</li>
<li><code>C.E_QIIN</code> | <code>C.E_QIOUT</code> | <code>C.E_QIINOUT</code> — Quint In, Out and In/Out easings</li>
<li><code>C.E_EIN</code> | <code>C.E_EOUT</code> | <code>C.E_EINOUT</code> — Exponent In, Out and In/Out easings</li>
<li><code>C.E_CRIN</code> | <code>C.E_CROUT</code> | <code>C.E_CRINOUT</code> — Circular In, Out and In/Out easings</li>
<li><code>C.E_BIN</code> | <code>C.E_BOUT</code> | <code>C.E_BINOUT</code> — Back In, Out and In/Out easings</li>
</ul>
</li>
<li>Easings that require data<ul>
<li><code>C.E_PATH</code> — Path-based easing</li>
<li><code>C.E_CSEG</code> — Curve Segment-based easing</li>
<li><code>C.E_FUNC</code> — Function-based easing</li>
</ul>
</li>
</ul>
</li>
<li><a href="#path">Paths</a> <code>C.P_*</code><ul>
<li>Segment type<ul>
<li><code>C.P_MOVE</code> - Move-Segment</li>
<li><code>C.P_LINETO</code> - LineTo-Segment</li>
<li><code>C.P_CURVETO</code> - CurveTo-Segment</li>
</ul>
</li>
</ul>
</li>
<li><a href="#fill--stroke">Stroke</a> <code>C.PC_*</code><ul>
<li>Cap/Join type<ul>
<li><code>C.PC_ROUND</code></li>
<li><code>C.PC_BUTT</code></li>
<li><code>C.PC_MITER</code></li>
<li><code>C.PC_BEVEL</code></li>
<li><code>C.PC_SQUARE</code></li>
</ul>
</li>
</ul>
</li>
<li><a href="#elements-interactions">Composition</a><ul>
<li><code>C.C_SRC_OVER</code> - Source over</li>
<li><code>C.C_SRC_ATOP</code> - Source atop</li>
<li><code>C.C_SRC_IN</code> - Source in</li>
<li><code>C.C_SRC_OUT</code> - Source out</li>
<li><code>C.C_DST_OVER</code> - Destination over</li>
<li><code>C.C_DST_ATOP</code> - Destination atop</li>
<li><code>C.C_DST_IN</code> - Destination in</li>
<li><code>C.C_DST_OUT</code> - Destination out</li>
<li><code>C.C_LIGHTER</code> - Lighter</li>
<li><code>C.C_DARKER</code> - Darker</li>
<li><code>C.C_COPY</code> - Copy</li>
<li><code>C.C_XOR</code> - XOR</li>
</ul>
</li>
</ol>
<h3>Tweens</h3>
<p>Tween is some modification of the shape that continously changes shape state from one to another during some concrete time period. If you want to move a shape from one point to another, rotate from one angle to another, scale it from one size to another, change its opacity, ..., in some time frame, this is the thing you need.</p>
<p>There's a generic method of adding any type of the tween, but for better code-readability it is recommended to use the concrete methods instead of gereric one. Though, we need to give you a spec of it anyway, because it will make you know what things are general for tweens:</p>
<blockquote>
<p>♦ <code>builder.tween % (type: C.T_*, band: Array[2,Float], [data: Any], [easing: C.E_* | Object]) =&gt; Builder</code></p>
</blockquote>
<p>It takes type of the tween, its time-band (relatively to the band of its owner), optional data that will be passed to tween function on every call, and optional easing of the tween (the function that changes the speed tween performs depending of current time), which is a type constant or a custom object created with <code>B.easing()</code> (see <a href="#tween-easings">Easings</a> section below to know more about easings). See type constants for tweens and easings in <a href="#constants">Constants</a> section. Examples:</p>
<pre><code>b().rect([10, 10], [90, 30])
   .tween(C.T_TRANSLATE, [0, 3],
          B.path([ [0, 0], [20, 20], [10, 30],
                   [70, 70], [12, 12], [100, 50] ]));
b().rect([40, 40], [12, 70])
   .tween(C.T_ROTATE, [0, 1.5],
          [ Math.PI, Math.PI/2 ], C.E_CINOUT)
   .tween(C.T_ROTATE, [1.5, 3],
          [ Math.PI/2, Math.PI ], C.E_QINOUT);
</code></pre>
<p>Time bands for tweens act the same way as band-restricted <a href="#modifiers--painters">modifiers</a>.</p>
<p>Now, the methods for concrete tweens:</p>
<blockquote>
<p>♦ <code>builder.trans % (band: Array[2,Float], points: Array[2,Array[2, Float]], [easing: C.E_* | Object]) =&gt; Builder</code></p>
</blockquote>
<p>Translates the shape from point to point (handle is at registration point) during the given time frame:</p>
<pre><code>b().trans([7, 30], [[12, 40], [50, 30]]); // from (12, 40) to (50, 30)
</code></pre>
<blockquote>
<p>♦ <code>builder.transP % (band: Array[2,Float], path: String | Path, [easing: C.E_* | Object]) =&gt; Builder</code></p>
</blockquote>
<p>Translate the shape along the points of given path. This one is useful when you want something to follow some other thing or move along some complex line or curve. The speed may be controlled with easing.</p>
<pre><code>b().transP([5, 13], 'M40 40 C40 40 20 120 200 30 L80 80 '+
                    'C70 70 24 35 40 100 L40 40 Z');
b().transP([0, 20], B.path([[ 40, 40 ],
                    [ 40, 40, 20, 120, 200, 30 ],
                    [ 80, 80 ],
                    [ 70, 70, 24, 35, 40, 100 ],
                    [ 40, 40 ]));
b().transP([1, 9], 'M30 30 L0 0 Z', C.E_QIOUT);
</code></pre>
<blockquote>
<p>♦ <code>builder.rotate % (band: Array[2,Float], angles: Array[2,Float], [easing: C.E_* | Object]) =&gt; Builder</code></p>
</blockquote>
<p>Rotates the shape around its registration point, starting from first angle to another angle (in radians):</p>
<pre><code>b().rotate([5, 20], [ 0, Math.PI * 2 ]);
b().rotate([1, 10], [ Math.PI / 2, Math.PI * 2 ], C.E_IN);
</code></pre>
<blockquote>
<p>♦ <code>builder.rotateP % (band: Array[2,Float], [easing: C.E_* | Object]) =&gt; Builder</code></p>
</blockquote>
<p>Rotates the shape to be aligned to the current moving path, so it will be pointed perpendicularly to the active section. That's why this tween makes sense (and works) only when used with <code>translate()</code> (which in fact constructs a linear path from given points) and <code>translateP()</code>. If you have two translate tweens applied one after another, you may specify a wrapping band for <code>rotateP</code>.</p>
<pre><code> b().translate([2, 4], [[20, 15], [30, 40]]).rotateP([2, 4]);
 b().translateP([0, 6], 'M20 20 L40 40 Z')
    .translate([4, 9], [[12, 40], [25, 16]]).rotateP([0, 9], C.E_IN);
</code></pre>
<blockquote>
<p>♦ <code>builder.scale % (band: Array[2,Float], values: Array[2,Array[2, Float]], [easing: C.E_* | Object]) =&gt; Builder</code></p>
</blockquote>
<p>Scales the shape by x and y separately. The values required to be specified in this format: <code>[ [ startScaleX, startScaleY ], [ endScaleX, endScaleY ] ]</code>, all of them are relative to the starting size.</p>
<pre><code>b().scale([3, 6], [[.5, .3], [1.7, 2.1]]);
</code></pre>
<blockquote>
<p>♦ <code>builder.xscale % (band: Array[2,Float], values: Array[2, Float], [easing: C.E_* | Object]) =&gt; Builder</code></p>
</blockquote>
<p>Scales the shape both width and height simultaneously. So it is literally means 'make shape larger' or 'make shape smaller'.</p>
<pre><code>b().xscale([3, 9], [.5, 2]);
</code></pre>
<blockquote>
<p>♦ <code>builder.alpha % (band: Array[2,Float], values: Array[2,Float], [easing: C.E_* | Object]) =&gt; Builder</code></p>
</blockquote>
<p>Changes the opacity value of the shape through time. The acceptable values are fractions of 1.</p>
<pre><code>b().alpha([8, 16], [.5, 1]);
b().alpha([1.2, 3], [0, 1], C.E_COUT);
</code></pre>
<p>The order in which different types of tweens are applied is fixed internally (<code>[ C.T_TRANSLATE, C.T_SCALE, C.T_ROTATE, C.T_ROT_TO_PATH, C.T_ALPHA ]</code>), so you may add them in any succession. However, order of the tweens of the <em>same type</em> do matters if their time frames overlap — the corresponding state value is alwasy overwritten with the last-added tween.</p>
<h4>Relativity</h4>
<p>Every tween has an ability to be specified in relative way (the same as modifiers, since tweens are in fact a special case of modifiers). You may add <code>r</code> in front of the name of any of described functions and it will give you a relative-time variant. It means that using these methods you may specify bands relatively to the owner's band with <code>0..1</code> range. For example, this:</p>
<pre><code>b().band([2, 5]).rtrans([1/3, 0.5], [[12, 40], [50, 30]]);
</code></pre>
<p>will mean that you want translation to start at <code>1/3</code> of the element's band and finish at the half of its band, without specifiying concrete seconds for the tween (in terms of usual <em>absolute time</em> tweens, its band'd be <code>[ 2 + (1 / 3) * (5 - 2), 2 + 0.5 * (5 - 2) ] == [3, 3.5]</code>). It looks not so efficient with small band and a single tween example, but it will probably help you a lot, when you'll have a lot of tweens for some element with complex band and you'd want just to reduce/increase the element's band without affecting the <em>proportions</em> of the tweens and requiring to change every band of each tween separately.</p>
<h3>Tween Easings</h3>
<p>Easing of the tween is the function that takes actual time of the tween animation and substitues it with another, returned to the tween. The function of time. In result you may get the effect of accelerating or slowing down or even bouncing animations. Every tween method has an optional possibility to use some provided easing function or any custom one:</p>
<pre><code>b().trans(..., C.E_CINOUT);
b().xscale(..., function(t) { return 1-t; });
b().alpha(..., B.easing(function(t, obj) {
                 return obj.width * t;
               }, obj));
</code></pre>
<p>If there's no easing specified for a tween, you may say that it has easing function of <code>function(t) { return t; }</code>. Both <code>t</code> parameter value and required returned value are values from <code>[0..1]</code> range, relative to the duration of the tween.</p>
<p>There are a lot of predefined easing (27, currently), see <a href="#constants">Constants</a> for a list of their types. All predefined easings are curve-segment-based, it means that the easing function takes a correspoing point from some internal curve segment of a path and returns it's position relatively to segment length. You may see all of them (and some more) in action <a href="http://easings.net/">at this site</a>.</p>
<pre><code>b().rotate([2, 17], [0, Math.PI*2], C.E_QTIN);
</code></pre>
<p>You have, however, the option to set any function you want (again, just ensure that it returns value from 0 to 1):</p>
<pre><code>b().rotate([2, 17], [0, Math.PI*2], function(t) { return 1-t; });
</code></pre>
<p>If you want the easing based on segment, use <code>B.easingC()</code> method and pass 6 curve segment points there:</p>
<pre><code>b().rotate([2, 17], [0, Math.PI*2], B.easingC([20, 20, 19, 30, 45, 120]));
</code></pre>
<p>If you want the easing based on segment, use <code>B.easingP()</code> method and pass there a path with either string or array of points:</p>
<pre><code>b().rotate([2, 17], [0, Math.PI*2], B.easingP('M20 20 C20 20 19 30 45 120 Z'));
b().rotate([2, 17], [0, Math.PI*2], B.easingP([[20, 20], [20, 20, 19, 30, 45, 120], [20, 20]]));
</code></pre>
<h3>Time Easing</h3>
<p>Except easing for concrete tweens, you may want to set a function to substitute time for all tweens of the shape in the range of shape's band. There are two methods for it, first one gets time in the bounds of the band, the second one gets time in the bounds of <code>[0..1]</code>, relative to the band.</p>
<blockquote>
<p>♦ <code>builder.time % (f: Function(t: Float)) =&gt; Builder</code></p>
</blockquote>
<pre><code>b().band([3, 16]).time(function(t) {
    console.log(t); // will get values from 3 to 16
    return 19-t; // turn time backwards
});
</code></pre>
<blockquote>
<p>♦ <code>builder.tease % (ease: Function(t: Float)) =&gt; Builder</code></p>
</blockquote>
<pre><code>b().band([3, 16]).tease(function(t) {
    console.log(t); // will get values from 0 to 1
    return 1-t; // turn time backwards
});
</code></pre>
<h3>Repeat Modes</h3>
<!-- TODO: test repeat methods at global level and in different levels of inside -->

<p>Sometimes you want certain animation of a shape or shape group to repeat until the end. Use the repeat modes to achieve this! If you set a repeat mode to a shape, it keeps repeating/applying its tweens until the finish of the parent band. The band of the element to repeat must be less than the band of the parent to make it work as it should. So, if parent band is <code>[2, 102]</code> and a child has band <code>[0, 5]</code> with <code>loop()</code> mode, then the tweens of the last will be repeated exactly 25 times. Please always remember that default band for all elements is <code>[0, Infinity]</code>, so when you are using repeat modes you'll often need to specify band not only for the shape to repeat, but also for its parents, if they exist — in most cases, without accurate setting of a band, you may see no effect of repeat mode.</p>
<p>There are three repeat modes currently supported:</p>
<ul>
<li><code>C.R_ONCE</code> — play once and disappear (<code>once()</code>)</li>
<li><code>C.R_STAY</code> — play once and stay at the last frame (<code>stay()</code>)</li>
<li><code>C.R_REPEAT</code> — repeat playing (<code>loop()</code>)</li>
<li><code>C.R_BOUNCE</code> — play forward, then backward, and repeat (<code>bounce()</code>)</li>
</ul>
<p>You may set one with a constant or using a concrete method (provided in brackets). You may also reset <code>loop()</code> and <code>bounce()</code> modes with <code>once()</code> call in the end:</p>
<pre><code>b().band([0, 10]).mode(C.R_REPEAT);
b().band([0, 20]).add(b().band([0, 3]).loop());
b().rect([20, 40], [10, 70]).rotate([0, 2], [0, Math.PI]).band([0, 2]).bounce();
</code></pre>
<blockquote>
<p>♦ <code>builder.mode % (mode: C.R_*) =&gt; Builder</code></p>
<p>♦ <code>builder.once % () =&gt; Builder</code></p>
<p>♦ <code>builder.loop % () =&gt; Builder</code></p>
<p>♦ <code>builder.bounce % () =&gt; Builder</code></p>
</blockquote>
<h3>Modifiers &amp; Painters</h3>
<p>Every <a href="#element">Element</a> stores two split parts of data inside: static and dynamic. Static part is a read/only data that will not be changed through animation process. Dynamic part is about the actions to perform with (or parameters to apply to) these drawn things on every frame, so it is allowed to be changed. Static data (called <code>xdata</code>) contains links to the current path or text or image, its registration point, band and repeat mode. Dynamic part (called <code>state</code>) contains shape coordinates, scale for each side, rotation angle, opacity and current time position.</p>
<p>Conforming to canvas mechanics, on every frame, to draw every single element, we need two steps. Fisrt step is to modify the canvas coordinate space to match element position, rotation angle and scale; it is the data we take from <code>state</code>. Second step is to draw the element in current coordinate space; is uses data from <code>xdata</code>.</p>
<p>See <a href="#the-flow">The Flow</a> section for more detailed description.</p>
<h4>Modifiers</h4>
<p><strong>Modifier</strong> is the function that gets current local time and changes shape's <code>state</code> conforming to it. It may even substitute this time. And any shape may have any number of such functions, they will be applied to this shape one by one on every frame before drawing. Tweens are also modifiers. In fact, they are prepared when you load your scene into player. One modifier checks if element band fits current time. If any of modifiers fail, the element will not be drawn.</p>
<h5>Usual Modifiers</h5>
<blockquote>
<p>♦ <code>builder.modify % (modifier: Function(time: Float, duration: Float, data: Any), [data: Any], [priority: Integer]) =&gt; Builder</code></p>
</blockquote>
<p>To add modifier function to a shape, use <code>modify()</code> method. This function gets local time (if band is <code>[2, 17]</code>, then this value will be in <code>[0..15]</code> range), which gives you the ability to freely modify state or change anything at the scene. Second argument for this function is the duration of modifier's band, so you may use it to get value in <code>[0..1]</code> range in any moment; its <code>this</code> pointer points to the shape's <code>state</code>, so you may freely <em>modify</em> it.</p>
<p>Every such function returns <code>null</code> by default (when you return nothing) and it means "do not stop execution, continue", the same as <code>return true</code>. It is done to let you forget to return something, so all modifiers do pass by default. If you will manually return <code>false</code> (treat it as "please stop execution, I don't need this element now"), the execution will stop. So it is optional to return something from modifier while you want to see it, but if you return <code>false</code> and only <code>false</code> (not <code>0</code>, <code>null</code>, empty string or something), element will not be rendered this time; any other return values or omitting return statement are considered as <code>true</code>, do render.</p>
<!-- TODO: `rx` and `ry` are replaced on every frame, so user may not change the registration point during the animation. Is it ok? -->

<pre><code>b().band([0, 15]).modify(function(t) {
    this.x = 10 * t;
    this.sy = t / 15;
});

// adding prepared modifier to several shapes
// and passing some data to it
var m_prepared = function(t, value) {
    this.angle = Math.PI / (t * value);
};
b().band([0, 10]).modify(m_prepared, .1);
b().band([0, 10]).modify(m_prepared, .5);
b().band([0, 10]).modify(m_prepared, .7);
b().band([0, 10]).modify(m_prepared, 1);

// you may add several modifiers to one shape
var my_shape = b();
my_shape.modify(m_prepared, .6);
my_shape.modify(function(t, duration) {
    this.alpha = t / duration;
});

// returning false if this element must not be visible
b().band([0, 8]).modify(function(t) {
    return (t &gt; 4);
});
</code></pre>
<p>In fact, when you change the <code>state</code> in any modifier, you change not the current element <code>.state</code>, but the cloned state, which will be applied only when all modifiers passed successfully. It gives you the ability to safely get previous (from last render) element state with <code>b().v.state</code> (there is no meaning in modifying it, it is the <em>previous</em> state). Inside the modifier, previous state is also accessible through <code>this._</code> (<code>this._.x</code>, <code>this._.angle</code>, <code>this._.alpha</code>, ....). Also, there is a link to current element (modifier owner) as <code>this.$</code>, but we hope (and we will try to make it so) you will need it only in rare cases. Anyway, you may wrap <code>this.$</code> with <code>b()</code> (like <code>b(this.$)</code>), and you will get the same builder you use outside from cache (if it wasn't created, it will be created).</p>
<p>As you may noticed in example, you may optionally pass <code>data</code> object of any type, it will be passed to your modifier as second parameter every time it will be called. Also, you may specify a priority number, the higher this number, the later this modifier will be called in the modifiers sequence. The modifiers with the same priority will be called in the order of addition.</p>
<p>It is ok to have a number of modifiers that check some flag and return <code>false</code> ("do not render element") if it is (not) set, please don't hesitate to use it — if it work slowly, it will be our fault :) (but, of course, it is your fault, if you have no more than 40 of such modifiers for each element ;) ). More of that, it is the intended practice to pass some "context" object to modifiers, so you may check global stuff, like this:</p>
<pre><code>var scene = b();
var ctx = {};
// which elements to show
ctx.show = [ false, true, true, false, false,
             true, false, true, false, true ];
for (var i = 0; i &lt; 10; i++) {
    b().rect([10, 10], 5)
       .modify((function(i) { // closure for i
          return function(t, duration, ctx) {
             return ctx.show[i];
          }
        })(i), ctx);
};
</code></pre>
<p>However, please don't forget about <a href="#elements-interactions"><code>data()</code> method</a>. It will better fit you needs (and speed) in most cases.</p>
<p><strong>Note:</strong> Please note that <code>t</code> and <code>duration</code> values are not totally exact values of time, since due to the pitfalls of floating point operations they have no possibility to be such. These values are the result of operations with values rounded to some internal precision value (we keep it as maximum as we can, currently it is <code>10^-9</code>).</p>
<!-- TODO: priority -->

<h5>Band-Restricted Modifiers</h5>
<blockquote>
<p>♦ <code>builder.modify % (band: [Array, 2], modifier: Function(time: Float, duration: Float, data: Any), [data: Any], [priority: Integer]) =&gt; Builder</code></p>
</blockquote>
<p>The modifiers specified above do act only during the time that exactly matches to element's lifetime. Sometimes it is not the only case you want to achieve and you probably want the modifier to have its own lifecycle somewhere inside of the element's band, like in case of tweens, and you actually have the ability to do it! Using the very same <code>modify</code> method you may specify the restricting band for the modifier:</p>
<pre><code>b().band([2, 15]).modify([3, 7], function(t, duration) {
    this.sx = this.sy = t / duration;
});
</code></pre>
<p>This will call the modifier only during the global time of <code>[2 + 3, 2 + 7] == [5, 9]</code>, and it will pass not the duration of the element's band inside, but the duration of the modifier's band (<code>4</code>, in this case). The other things are the same as for usual modifiers.</p>
<h5>Triggering Modifiers</h5>
<blockquote>
<p>♦ <code>builder.modify % (time: Float, modifier: Function(time: Float, duration: Float, data: Any), [data: Any], [priority: Integer]) =&gt; Builder</code></p>
</blockquote>
<p><strong>NB:</strong> Triggering modifiers are in beta state, they are not totally guaranteed to be actually called for now, i.e. the one will not be called if it's time was accidentally falled between browser-generated frames in the end of element's band.</p>
<p>Again, with the very same <code>modify</code> method, you may emulate the 'event' to fire when some time position was reached with 'playhead', just pass the local time of the element:</p>
<pre><code>b().band([2, 19]).modify(5, function(t) {
    console.log("I've reached the time of 5, probably a bit lately, difference is: " + (t - 5));
});
</code></pre>
<p>This modifier will be called at the global time of <code>2 + 5 == 7</code> or a bit later, if FPS was so low that this exact time was skipped or due to some other problems, but we intend to ensure you that this modifier will be called sooner or later, 'whatever happens' (in current version it may be not). The <code>t</code> value will be the actual time of the call, so you may use it to check the time delta between expected and actual time and use it in calculations. Again, other points are the same as in case of usual modifiers.</p>
<blockquote>
<p>♦ <code>builder.at % (time: Float, function: Function(time: Float, duration: Float, data: Any), [data: Any], [priority: Integer]) =&gt; Builder</code></p>
</blockquote>
<p>There is also an alias method for this case, named <code>at</code>:</p>
<pre><code>var scene = b();
scene.add(b().rect([10, 10], 5)
             .at(1.2, function(t) {
                 // this will never happen
                if (t &lt; 1.2) throw new Error("You've lied to me!");
             }));
</code></pre>
<p><strong>Note:</strong> <code>duration</code> is duration of the element's band here.</p>
<h5>Relativity</h5>
<blockquote>
<p>♦ <code>builder.rmodify % (modifier: Function(time: Float, duration: Float, data: Any), [data: Any], [priority: Integer]) =&gt; Builder</code></p>
<p>♦ <code>builder.rmodify % (band: [Array, 2], modifier: Function(time: Float, duration: Float, data: Any), [data: Any], [priority: Integer]) =&gt; Builder</code></p>
<p>♦ <code>builder.rmodify % (time: Float, modifier: Function(time: Float, duration: Float, data: Any), [data: Any], [priority: Integer]) =&gt; Builder</code></p>
<p>♦ <code>builder.rat % (time: Float, function: Function(time: Float, duration: Float, data: Any), [data: Any], [priority: Integer]) =&gt; Builder</code></p>
</blockquote>
<p>Sometimes you don't know or don't want to use the time values in seconds, but do want to specify and get them relatively to an element's lifecycle. There are the <code>rmodify</code> method variants for you. Despite time values they act the same way as the described ones, but now you have the ability to say "I want this modifier to be called at one third (1 / 3) of its element's band".</p>
<p>Usual modifiers just differ in receiving the time value in range of <code>[0..1]</code> among with element's band <code>duration</code>:</p>
<pre><code>b().band([2, 19]).rmodify(function(t, duration) {
    console.log("This value is from 0 to 1: " + t, ". And this is the actual time: " + (t * duration));
});
</code></pre>
<p>Band-restricted modifiers allow you to specify their band with relative time values (like "permorm this starting from 1 / 5 of element's band and end at the very end") and they receive <code>t</code> and <code>duration</code> values corresponding to modifier's band (other types of modifiers receive them relatively to containing element's band):</p>
<pre><code>b().band([2, 19]).rmodify([1/3, 1], function(t, duration) {
    console.log("Modifier position is: " + t + ". In terms of seconds it is " + (t * duration));
});
</code></pre>
<p>Triggering modifiers also allow you to use relative values when defining them, this one will be called at approx. <code>2 + ((19 - 2) / 3)</code>. The <code>t</code> and <code>duration</code> values are relative to element's band:</p>
<pre><code>b().band([2, 19]).rmodify(1 / 3, function(t, duration) {
    console.log("I've reached the time of one third, local time is: " + (t * duration) + " now.");
});
</code></pre>
<h5>So, to sum up</h5>
<p><strong>Modifiers with seconds-based values</strong> ( <em>absolute time</em> modifiers )</p>
<ul>
<li>Type 1: <em>Usual ones</em>: <code>b().modify(function(t, duration, ...) { ... })</code> — modifiers, which are called while element is alive for every of its update-request (request for new frame, spawned by browser), receiving the time of this request; they receive <code>t</code> in seconds, which is relative to the owning element's band (lifetime), and <code>duration</code> is the duration (in seconds, for sure) of that band; it is also acceptable to say that they have their band equal to the lifetime of their owning element, so there is no need in specifying it;</li>
<li>Type 2: <em>Band-restricted</em>: <code>b().modify([a, b], function(t, duration, ...) { ... })</code> — they have their own sub-band (lifetime) inside of the owning element's band and they are just called during that sub-band (if sub-band is wider than element's band, it is temporary reduced to match it, same way it works with element's children bands); <code>a</code> and <code>b</code> are specified in seconds relatively to element's band, however <code>t</code> value (in seconds) they receive is relative to the modifier sub-band, and <code>duration</code> is the duration (in seconds) of that sub-band.</li>
<li>Type 3: <em>Time-restricted</em> or <em>Trigger-like</em>: <code>b().modify(ct, function(t, duration, ...) { ... })</code> — they are guaranteed<sup>*</sup> to be called at the specified time of element's life or a bit later (if they occasionally missed that time, say, due to low FPS), and receive actial time of the call as <code>t</code>; <code>ct</code> is specified in seconds relatively to owning element's band and <code>t</code> value (actual time of the call), in seconds, is relative to the very same band, and <code>duration</code> is the duration of that band, in seconds again.</li>
</ul>
<p><strong>Modifiers with relative values</strong> ( <em>relative time</em> modifiers )</p>
<ul>
<li>Type 1: <em>Usual ones</em>: <code>b().rmodify(function(t, duration, ...) { ... })</code> — modifiers, which are called while element is alive for every of its update-request (request for new frame, spawned by browser), receiving the time of this request; they receive <code>t</code> in range of <code>[0..1]</code>, relatively to the owning element's band (lifetime), and <code>duration</code> is the duration (in seconds, for sure) of that band; it is also acceptable to say that they have their band equal to the lifetime of their owning element, so there is no need in specifying it;</li>
<li>Type 2: <em>Band-restricted</em>: <code>b().rmodify([a, b], function(t, duration, ...) { ... })</code> — they have their own sub-band (lifetime) inside of the owning element's band and they are just called during that sub-band (if sub-band is wider than element's band, it is temporary reduced to match it, same way it works with element's children bands); <code>a</code> and <code>b</code> are specified in range of <code>[0..1]</code> relatively to element's band, however <code>t</code> value (in range of <code>[0..1]</code>) they receive is relative to the modifier sub-band, and <code>duration</code> is the duration (in seconds) of that sub-band, so you always may get time in seconds relatively to modifier's band with <code>t * duration</code>.</li>
<li>Type 3: <em>Time-restricted</em> or <em>Trigger-like</em>: <code>b().rmodify(ct, function(t, duration, ...) { ... })</code> — they are guaranteed<sup>*</sup> to be called at the specified time of element's life or a bit later (if they occasionally missed that time, say, due to low FPS), and receive actual time of the call as <code>t</code>; <code>ct</code> is specified in <code>[0..1]</code> range relatively to owning element's band and <code>t</code> value, in range of <code>[0..1]</code>, is relative to the very same band, and <code>duration</code> is the duration of that band, in seconds.</li>
</ul>
<p><sup>*</sup> actually <em>not so</em>, in the current version</p>
<p>Notes:</p>
<ul>
<li>relative time modifiers give you the ability to specify fractions of bands (for band- and time-restricted ones), where, say, <code>0</code> will mean start of that band, <code>1/2</code> will mean half of that band and <code>1</code> will mean the end of that band; just if you haven't noticed</li>
<li>in case of <code>t</code> values you receive within <code>[0..1]</code> ranges, please do not expect to always get the exact <code>0</code> or <code>1</code> value in modifier, since it may never happen due to FPS.</li>
<li>time values are often the subject to fail in floating point operations, since then they are actually returned mathematically rounded to some internal precision (currently <code>10^-9</code>), so please take it in consideration if you plan to make models of Higgs Boson using the player API.</li>
</ul>
<h4>Painters</h4>
<p><strong>Painter</strong> is the function that gets current context and applies shape's <code>xdata</code> to draw something. And any shape may have any number of such functions, they will be applied one by one on every frame to draw it. Debug function that draw registration points and moving paths are also painters. In fact, they are prepared when you load your scene into player.</p>
<blockquote>
<p>♦ <code>builder.paint % (painter: Function(ctx: Context, data: Any), [data: Any], [priority: Integer]) =&gt; Builder</code></p>
</blockquote>
<p>To add painter function to a shape, use <code>paint()</code> method. This function gets canvas context; its <code>this</code> pointer points to the shape's <code>xdata</code>, so you may use it to draw something, you may even modify anything at first level of <code>xdata</code>.</p>
<!-- TODO: or `xdata` is allowed to modify? -->

<pre><code>b().paint(function(ctx) {
    ctx.fillStyle = '#f00';
    ctx.beginPath();
    ctx.moveTo(50, 50);
    ctx.lineTo(60, 60);
    ctx.lineTo(160, 50);
    ctx.closePath();
    ctx.fill();
});

// adding prepared painter to several shapes
// and passing some data to it
var p_prepared = function(ctx, text) {
    this.text.lines = text;
    this.text.apply(ctx);
}
b().paint(p_prepared, "Y");
b().paint(p_prepared, "M");
b().paint(p_prepared, "C");
b().paint(p_prepared, "A");

// you may add several painters to one shape
var my_shape = b();
my_shape.paint(p_prepared, "G");
my_shape.paint(function(ctx) {
    ctx.arc(....);
});
</code></pre>
<p>As for modifiers, you may optionally pass <code>data</code> object of any type, and it will be passed to your painter as second parameter every time it will be called. And again, you may specify a priority number — the higher this number, the later this painter will be called in the painters sequence. The painters with the same priority will be called in the order of addition. Also, there is a link to current element (painter owner) as <code>this.$</code>, but we hope (and we will try to make it so) you will need it only in rare cases.</p>
<blockquote>
<p>We strongly encourage you to use prefixes in the names of your Modifiers/Painters/Handlers if they are prepared before, so you'd easy distinguish what is what even if you have a lot of code. We use <code>m_</code>, <code>p_</code> and <code>h_</code> correspondingly.</p>
</blockquote>
<h4>Removing modifiers or painters</h4>
<blockquote>
<p>♦ <code>builder.unmodify % (modifier: Function) =&gt; Builder</code></p>
</blockquote>
<p>This method will remove previously added modifier from the element, in the way like:</p>
<pre><code>var m_temp = function(t) {...};
var my_elm = b();
my_elm.modify(m_temp);
...
my_elm.unmodify(m_temp);
</code></pre>
<blockquote>
<p>♦ <code>builder.unpaint % (painter: Function) =&gt; Builder</code></p>
</blockquote>
<p>This method will remove previously added painter from the element, in the way like:</p>
<pre><code>var p_temp = function(ctx) {...};
var my_elm = b();
my_elm.paint(p_temp);
...
my_elm.unpaint(p_temp);
</code></pre>
<h3>Events</h3>
<p>Every shape may receive the events user perform with the canvas. Shape receives all occuring events if it was visible for user in the moment when the event took place, its position has no matter.</p>
<!-- TODO: need to test the case when shape is not visible but there was a click and it receives it -->

<blockquote>
<p>♦ <code>builder.on % (type: C.X_*, handler: Function(evt: Event, t: Float)) =&gt; Builder</code></p>
</blockquote>
<p><strong>NB</strong>: Event handling way may change in near future, it is not a stable part of API for the moment. Look for the changes of this document when you use new version of player.</p>
<p>Currently, only keyup / keydown / keypress (<code>C.X_KUP</code>, <code>C.X_KDOWN</code>, <code>C.X_KPRESS</code>) and mclick / mdown / mup / mmove (<code>C.X_MCLICK</code>, <code>C.X_MDOWN</code>, <code>C.X_MUP</code>, <code>C.X_MMOVE</code>) events are supported.</p>
<p>Event handlers have the same access to state as modifiers do (in fact, they are modifiers that perform last, when all others modifiers were performed):</p>
<pre><code>b().on(C.X_MCLICK, function(evt) {
    if (this.$.contains(evt.pos)) {
        this.x = evt.pos[0];
        this.y = evt.pos[1];
    }
    return true;
});

b().on(C.X_KPRESS, function(evt) {
    console.log(evt);
});
</code></pre>
<p>You may see the use of <code>contains()</code> in the example: it tests if shape has the point given, and it is a special method made to match current time of animation, use it only in events handlers.</p>
<p>Currently, every mouse event contains only a mouse position (<code>evt.pos</code>) and every key event contains only a pressed key info (<code>evt.key</code>).</p>
<p>The second optional incoming argument for handler is <code>t</code>, it is a render time when handler-modifier was called.</p>
<h3>Time Jumps</h3>
<p>Sometimes you need to change time/frame while playing or on some event, mostly when you have some complex animation, like human body or so. Sometimes it is enough to jump in time, sometimes there's a lot of stuff in a scene, or even its frames calculated dynamically, so its easier to assign a name to frame.</p>
<p>There are more than one way to do it.</p>
<p>To perform a jump in some concrete moment of time, you may either use a <code>time()</code> function described <a href="#time-easing">above</a>:</p>
<pre><code>b().band([5, 15]).time(function(t) {
    if (t &gt; 10) return (t - 8); // the same as jump to local 2
    else return t;
});

b().band([5, 15]).tease(function(t) {
    if (t &gt; 0.5) return (t - 0.3); // the same as jump to local 2
    else return t;
});
</code></pre>
<p>Or you may jump with <a href="#modifiers">modifier</a>:</p>
<pre><code>b().band([5, 15]).modify(function(t) {
    if (t &gt; 5) this.p = 2; // this.p sets local time to jump
                           // to and proceed from
});

b().band([5, 15]).modify(function(t) {
    if (t &gt; 5) this.t = .2; // this.t sets relative time to jump
                            // to and proceed from
});
</code></pre>
<p>You may do the similar jump while handling an <a href="#events">event</a>:</p>
<pre><code>b().band(...).on(C.X_MCLICK, function(evt) {
    if (evt.pos[0] &gt; 50) this.t = 2; // or this.p = .2
});
</code></pre>
<p>Also you may set a name to some frame using <code>key()</code> function and jump to it with modifier or event handler by assigning the name to <code>this.key</code>:</p>
<blockquote>
<p>♦ <code>builder.key % (name: String, value: Float) =&gt; Builder</code></p>
</blockquote>
<pre><code>b().band([5, 45])
   .add(b('red').rect(...).band([0, 10])
                          .alpha([0, 2], [0, 1])
                          .rotate([2, 5], ...)
                          .trans([5, 10]))
   .add(b('blue').rect(...).band([10, 20])
                           .alpha([0, 1], [0, 1])
                           .rotate([1, 6], ...)
                           .trans([6, 10], ...))
   .key('red-appeared', 2) // value is local time
   .key('red-rotated', 5)
   .key('red-moved', 10)
   .key('blue-appeared', 11)
   .key('blue-rotated', 16)
   .key('blue-moved', 20)
   .on(C.X_MCLICK, function(evt) {
       if (evt.pos[0] &gt; 50) this.key = 'blue-rotated';
   })
   .modify(function(t) {
       if (t &gt; 20) this.key = 'red-appeared';
   });
</code></pre>
<h3>Elements Interactions</h3>
<blockquote>
<p>♦ <code>builder.take % (b: Builder) =&gt; Builder</code></p>
</blockquote>
<p>Make the given <code>Builder</code> to be the source of the data for current <code>Builder</code>, its contents pointers will be copied so any changes of fill, stroke, path, text, shape will apply to both instances (the same for children, they are not cloned, but pointers to them are copied):</p>
<pre><code>var src = b().rect([40, 40], 20).fill('#006');
var clone = b().take(src).fill('#f06').move([70, 70]);
// fill will be changed to `#f06` for both `src` and `clone`
</code></pre>
<blockquote>
<p>♦ <code>builder.use % (b: Builder) =&gt; Builder</code></p>
</blockquote>
<p>Use the given <code>Builder</code>  to make a clone of the data for this <code>Builder</code>, all its contents, including children, will be cloned so it will be the separate object, but with the same content:</p>
<pre><code>var src = b().rect([40, 40], 20).fill('#006');
var clone = b().use(src).fill('#f06').move([70, 70]);
// fill will be separate for `src` and `clone`, as it is usually expected
</code></pre>
<p><strong>NB</strong>: <code>clone = b().use(src)</code> in fact is equal to <code>clone = b(src)</code>, you may use any method you prefer.</p>
<blockquote>
<p>♦ <code>builder.disable % () =&gt; Builder</code></p>
</blockquote>
<p>Disable an element, so it will not be rendered or calculated at all, including its children. It is the same to setting <code>b().v.disabled</code> (or <code>this.$.disabled</code> in modifiers/painters) to <code>true</code>. If you disable an element from inside of its own modifier, you can not enable it back from the same modifier, because this modifier will not be called at all while the element stays disabled — you only may enable it from outside. Another variant if you want to hide element temporary is to use the <a href="#modifiers">return value of modifier</a>, and I can't say which one is better: return values work good if element depends on its local state a lot, disabling works good when you make a decision globally or you enable/disable a lot of elements at one moment.</p>
<pre><code>var first = b('first')....;
var second = b('second')....;
var scene = b().add(first)
               .add(second)
    .modify(function(t) {
        if ((Math.floor(t) % 2) == 0) {
            first.disable();
            second.enable();
        } else {
            first.enable();
            second.disable();
        }
    });
</code></pre>
<p>Hope you've noticed trick: you may easily re-enable (not to restore, if it is removed — then it is removed) the element from it's parent: wrap this element with an empty another, and add a modifier to a new parent — there you may freely disable/enable any of children elements any number of times, this modifier will be called all through the parent band.</p>
<p>By the way, disabling is useful to switch scenes, for example:</p>
<pre><code>var scene1 = b()....;
var scene2 = b()....;
var scene3 = b()....;
scene1.on(C.X_MCLICK, function(evt) {
            if (/* next button clicked */) {
                scene1.disable();
                scene2.enable();
            }
         });
scene2.modify(function(t) {
            if (t &gt; 10) {
                scene2.disable();
                scene3.enable();
            }
         });
</code></pre>
<p>However, if you want to remove a number of elements forever, and this number is really big and/or you see that all this disabling stuff works slow in your case, may be it is better to <a href="#structures"><code>remove()</code> it</a>. But if it works ok, disabling is nicer and faster way.</p>
<p>Here are the differences in hiding-disabling-removing:</p>
<ul>
<li>Hiding an element (returning <code>false</code> from modifier) stops its rendering sequence but calls all modifiers before and calls this modifier every render even if the element is hidden, just stops and returns at this point: skipping next modifiers, drawing, and skipping all of its children logic/painiting, if there are any (no modifiers will be called for any of the children since they are not even calculated).</li>
<li>Disabling an element sets its <code>disabled</code> flag to <code>true</code>. This flag is checked on every render call for this element, <em>before</em> any time-checking / time-jumping, modifiers and painters, so no modifiers will be called nor for this element nor for its children, if any. However, if you enable this element from its parent, neighbour or somewhere outside, flag-check will pass and modifiers will be called again (and for children) like there's nothing happend.</li>
<li>Removing the element removes this element <em>totally</em>. There is no such element in the scene anymore. Don't expect it to appear again) (...Until you re-add it, if you really serious in it, but pssssst, you really don't need it, are you?).</li>
</ul>
<blockquote>
<p>♦ <code>builder.enable % () =&gt; Builder</code></p>
</blockquote>
<p>The inverse to <code>disable()</code> operation. Enables element back, so it will participate in calculations. It is the same to setting <code>b().v.disabled</code> (or <code>this.$.disabled</code> in modifiers/painters) to <code>false</code>.</p>
<blockquote>
<p>♦ <code>builder.each % (visitor: Function(elm: Element)) =&gt; Builder</code></p>
</blockquote>
<p>With <code>each()</code> method you may loop through all of the children of the element. Note that you get the <code>Element</code> instance each time, not the <code>Builder</code>, so if you want, you may wrap it or may not:</p>
<pre><code>var root = b();
for (var i = 0; i &lt; 100; i++) {
  root.add(b().circle([i*10, i*10], 5));
}
root.each(function(elm) {
  b(elm).stroke('#f00');
});
</code></pre>
<p>Be aware that if you plan to remove some child of some element while iterating through this element, it will fail, because children data will be modified in this moment from the inside, without notifying parent element about that fact, and element will keep iterating over non-existing elements. To solve this, use <code>iter()</code> method, described below.</p>
<blockquote>
<p>♦ <code>builder.deach % (visitor: Function(elm: Element)) =&gt; Builder</code></p>
</blockquote>
<p>There is a <code>deach()</code> ("deep-each") method with the same definition to iterate deeper through each of the <code>(</code>grand-<code>)*</code>children.</p>
<p>The note about removing applies here in the same way.</p>
<blockquote>
<p>♦ <code>builder.iter % (visitor: Function(elm: Element) =&gt; Boolean) =&gt; Builder</code></p>
</blockquote>
<p>This is the safe (but may be a bit more slow, because it uses iterator object) iteration over element's children, where you may return false (if return statement is omitted, it is considered as true) to delete the child from the element you are iterating over.</p>
<!-- TODO: more info -->

<blockquote>
<p>♦ <code>builder.diter % (visitor: Function(elm: Element) =&gt; Boolean) =&gt; Builder</code></p>
</blockquote>
<p>The same as <code>iter()</code>, but deep to <code>(</code>grand-<code>)*</code>children.</p>
<blockquote>
<p>♦ <code>builder.clear % () =&gt; Builder</code></p>
</blockquote>
<p>Detach all children of the element from itself and from the scene.</p>
<blockquote>
<p>♦ <code>builder.data % ([value: Any]) =&gt; Builder | Any</code></p>
</blockquote>
<p><code>data(...)</code>  method allows you to store any additional data in the element. If there is no parameter, method returns the current stored value. If there is one, method updates element's stored value with the passed one and returns <code>Builder</code> instance:</p>
<pre><code>var my_state = { foo: 'foo' };
var c = b().circle([140, 25], 20).data(my_state);
console.log(c.data().foo);
my_state.foo = 'bar';
console.log(c.data().foo);
</code></pre>
<p>Internally, this data is saved as <code>Element</code>'s <code>.__data</code> property, so you may access it directly with <code>b().v.__data</code>, if you want.</p>
<blockquote>
<p>♦ <code>builder.acomp % (comp: C.C_*) =&gt; Builder</code></p>
</blockquote>
<p>Change the global composition operation for alpha blending or any composition-trick you want. See the accepted values in <a href="#constants">Constants</a> section.</p>
<pre><code>// a trick on how to achieve no-looking-through
// elements on the layer with 0.5 opacity
b("scene").add(
    b("big").add(b().circle([80, 80], 60)
                    .fill('#f60')
                    .nostroke())
            .add(b().circle([130, 150], 60)
                    .fill('#f60')
                    .nostroke())
            .add(b().circle([230, 100], 60)
                    .fill('#f60')
                    .nostroke())
).add(
    b("small").acomp(C.C_DST_OUT)
              .add(b().circle([80, 80], 55)
                      .fill('#f60')
                      .nostroke())
              .add(b().circle([130, 150], 55)
                      .fill('#f60')
                      .nostroke())
              .add(b().circle([230, 100], 55)
                      .fill('#f60')
                      .nostroke())
).add(
    b("rect").acomp(C.C_DST_OUT)
             .rect([400 / 2, 250 / 2], [400, 250])
             .modify(function(t) { this.alpha = 0.5; })

);
</code></pre>
<p>We've created a <a href="http://animatron.com/composition-playground/">Composition Playground</a> for you to play with, say it, combinations of compositions. Just click layer to change its corresponding example (there are 10-or-so prepared examples that allow you to play with mostly all possible situations) or click an operation icon to change it to another.</p>
<blockquote>
<p>♦ <code>builder.mask % (mask: Element | Builder) =&gt; Builder</code></p>
</blockquote>
<p>Make one element to be a mask of another (so you call <code>mask</code> method of masked element and ). You don't need to add mask-element to the scene, except the case when you need it also to be drawn. Mask may be only one, but for sure it may contain any number of children elements inside. One mask may be used for several elements. It's transformation state corresponds to the state of masked parent.</p>
<pre><code>var cvs = document.getElementById('my-canvas'),
    w = cvs.width,
    h = cvs.height;

var bg = b('bg').circle([w/2,h/2], 100)
                .fill('#009');
var foo = b('mask').add(b().rect([0, 0], 100))
                   .add(b().rect([30, 50], 60))
                   .trans([0, 3], [[w, h], [0, 0]])
                   //.alpha([0, 3], [0, 1]);
var bar = b('masked').circle([0, 0], 60)
                     .fill('#ff0')
                     .trans([0, 3], [[0, 0], [w, h]])
                     //.alpha([0, 3], [.8, 1])
                     .mask(foo)
return b('scene').add(bg)
                 .add(foo)
                 .add(bar)
                 .trans([0, 3],
                        [[-w/2, -h/2], [w,h]]);
</code></pre>
<h3>Live Changes</h3>
<p>A very delicious feature is that you may change almost everything that happens on the scene in real time ("almost" — because we haven't tested all the variant of doing it, please file issues if you'll find something that don't works when it looks like it should).</p>
<p>Here's an example of live adding an element and animating it:</p>
<pre><code>var pos = [140, 25];

var circle = b().circle([0, 0], 20)
                .move(pos);

var blueRect = b('blue-rect').rect(pos, 70)
                  .fill('#009')
                  .stroke('#f00', 3)
                  .rotate([0, 10], [0, Math.PI / 2]);
var redRect = b('red-rect').rect([115, 90], 60)
                 .fill('#f00');

var scene = b().add(blueRect).add(redRect)
               .rotate([0, 10], [0, Math.PI]);

blueRect.modify(function(t) {
    if (t &gt; 1.5) {
        this.$.disabled = true;
        scene.add(circle.band([t, t+3])
                        .xscale([0, 3], [1, 0]));
    }
});
</code></pre>
<!-- TODO: Live changing paths or colors, more examples -->

<h3>Helpers</h3>
<h2>Scene</h2>
<h3>Manual Building</h3>
<h3>Element Structure</h3>
<h3>The Flow</h3>
<h3>Element reference</h3>
<h3>Path reference</h3>
<h3>Text reference</h3>
<h3>Events, Deeply</h3>
<h2>Modules</h2>
<h3>Collisions</h3>
<h2>Importers</h2>
<h3>Animatron</h3>