<!doctype html>
<html>
  <head>
    <title>The Animatron HTML5 Player Docs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />
    <link rel="stylesheet" href="./md.css" type="text/css" />
  </head>
<body><h1>Scripting</h1>
<h2>Overview</h2>
<p>Scripting will add to your animation an ability to react on input events, such as <em>mouse clicks</em> or <em>key presses</em>. For example, you can make your cat animation to follow your mouse cursor or open a web page if user clicks at a certain object or let user move an object with arrow keys, etc.</p>
<h2>The Basics</h2>
<p>To add a handler for the specific input event, you should first decide what kind of event you need. Here is a list of currently supported mouse events:</p>
<ul>
<li>Click — User clicked (pressed &amp; released left mouse button) at the object</li>
<li>Press — User pressed left mouse button within object bounds</li>
<li>Release — User released left mouse button within object bounds</li>
<li>Enter — User moved mouse and it's entered an object shape</li>
<li>Leave — User moved mouse and it's left an object shape</li>
<li>Move — User moved mouse somewhere inside a canvas</li>
</ul>
<p>And keyboard events:</p>
<ul>
<li>Type — User typed a character (pressed and released a key)</li>
<li>Press — User pressed a key</li>
<li>Release — User released a key</li>
</ul>
<p>Ok now you know which one you need and we're ready to implement a...</p>
<h2>Handler</h2>
<p>Handlers are just predefined functions which looks something like this:</p>
<pre><code>function onClick(ctx, evt, t) {
    // your code
}
</code></pre>
<p>We're done all the dirty work, so all you need is write a body of the handler function. But before that you should know something about how things are organized in the Player world.</p>
<h2>Elements</h2>
<p>Elements are core building blocks of the Player. If you see something it's an Element. Even something you can't see (like Audio tracks) is an element. Scenes (a group of animated elements) are elements too.</p>
<p>Elements are organized hierarchically (some elements may contain another elements and so on) into Scenes. And there is always a Root scene.</p>
<p>Elements has a shape, a border and a shadow. They also have a Pivot—a point they're rotated around, an Alpha—determines their transparency and other properties which are described in detail in <a href="http://animatron.com/player/doc/API.html">Full Player API documentation</a>.</p>
<p>Now let's try to create an element with a help of...</p>
<h2>Builder</h2>
<p>Builder is a special thing which main purpose (how you may suggest from it's name) is to construct Player's world.</p>
<p>Here is an example of how we could create a circle:</p>
<pre><code>var circle = _b('red_circle')   // _b is a builder
    .circle(                    // will create a rectangle
        [50, 50],               // at x = 50, y = 50
        20)                     // with radius = 20 pixels
    .fill(                      // and fill it with
        '#f00');                // red color
</code></pre>
<p>Ok, now lets add this element to our scene:</p>
<pre><code>this.$.scene.add(circle);
</code></pre>
<p><code>this.$</code> here is a current element. All elements has a link to their own scene so <code>this.$.scene</code> will refer to the element's scene and <code>add(elem)</code> will add an element to the scene.</p>
<p>And what if we wish to add an element to another scene? It's easy, we have to find this scene first and then add our circle to it:</p>
<pre><code>var anotherScene = this.findByName('another-scene')[0];
anotherScene.add(circle);
</code></pre>
<p>Please note that <code>this.findByName(name)</code> will return an array of elements (scene is an element too, remember?) even if there is just one matching element, so we need to pick just the first one: <code>[0]</code>.</p>
<p>Now we know something about building blocks but how the world goes alive?</p>
<h2>Tweens</h2>
<p>Tweens are changes. If you see something is changing this means that there is a Tween somewhere which describes that change.</p>
<p>Quick definition of tween is: tween is a value change over time.</p>
<p>For example, moving is a change of element's coordinates. Rotating is a change of element's angle. Vanishing is a change of element's opacity.</p>
<p>For example, if an object moves from one side of the canvas to another there is a tween of type TRANSLATE (i.e. current object coordinates are translated to coordinates of an other side of the canvas). If an object changes its opacity there is a tween of type ALPHA. If it rotates there is a tween of type ROTATE and so on. Even Audio tracks use tweens (of type VOLUME).</p>
<p>Let's see on a real example. We'll add a tween to our red circle and move it somewhere on the screen. Let's use Builder again:</p>
<pre><code>circle.trans(
    [0, 5],      // 1
    [[0, 0],     // 2
     [100, 0],   // 3
    C.E_DEF      // 4
);
</code></pre>
<ol>
<li>Defining a time range for our transition: from 0 to 5 secs</li>
<li>Defining a start point RELATIVE to our current position</li>
<li>An end point RELATIVE to current position</li>
<li>And define an Easing function (which will discuss a little bit later)</li>
</ol>
<p>Ok, now we know how to create elements and how to animate them so let's define our first click handler.</p>
<h2>Handler example</h2>
<p>In this example we well add a handler which will rotate a rectangle 360 degrees and then rotate it back. We will assign this handler on mouse click event so every time user will click on the object it will rotate:</p>
<pre><code>function onClick(ctx, evt, t) {
    var rect = null;
    var rects = this.findByName('rect');
    if (rects.length == 0) {                        // 1
        rect = _b('rect')
        .rect([50, 50], [30, 30])
        .fill('#0f')
        .build();                                   // 2

        this.$.scene.add(rect);
    } else {
        rect = rects[0];
    }

    _b(rect).rotate(
        [t, t + 2],
        [0, Math.PI * 2],                           // 3
        C.E_DEF);

    _b(rect).rotate(
        [t + 2, t + 4],
        [Math.PI * 2, 0],                           // 4
        C.E_DEF);
};
</code></pre>
<ol>
<li>Before all let's check if there any existing rects so each time user will click a mouse we'll not create a new rect but use an existing one.</li>
<li><code>build()</code> will create an Element here so we can use like it was found in the Player if it was a second time we're clicking the mouse</li>
<li>And rotate it forth in 2 seconds</li>
<li>And then back in next 2 seconds</li>
</ol>
<h2>Easing</h2>
<p>In a real world there is no constant speed. A bird moves with different speeds, a man walks faster or slower, a ball rolls faster and then slows down and stops. So we need something to emulate this real world (or maybe not so real) speed changes. This is why we need different Easing functions.</p>
<p>The <code>C.E_DEF</code> mentioned earlier in tweens is one of such functions which keeps speed of the change constant all the time. But more often you will need to use different Easing functions which are described in <a href="http://animatron.com/player/doc/API.html#tween-easings">Player API documentation</a>.</p>
<h2>Events</h2>
<p>Every handler receives an Event: <code>evt</code>. Depending on type of the event it could be a mouse event or keyboard events.</p>
<p>Mouse event contains coordinates of the mouse pointer:</p>
<pre><code>var x = evt.pos[0];
var y = evt.pos[1];
</code></pre>
<p>Keyboard events contains key code:</p>
<pre><code>var space = evt.key === 32;
var r_pressed = evt.char === 'R';
</code></pre></body>
</html>