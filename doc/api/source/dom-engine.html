<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * Copyright (c) 2011-@COPYRIGHT_YEAR by Animatron.
 * All rights are reserved.
 *
 * Animatron Player is licensed under the MIT License, see LICENSE.
 *
 * @VERSION
 */

// DOM Engine
// -----------------------------------------------------------------------------

var $doc = window.document;
    // DomEngine constants

var MARKER_ATTR = &#39;anm-player&#39;, // marks player existence on canvas element
    AUTO_MARKER_ATTR = &#39;anm-player-target&#39;, // marks that this element is a target for a player
    URL_ATTR = &#39;anm-url&#39;,
    SNAPSHOT_URL_ATTR = &#39;anm-src&#39;,
    IMPORTER_ATTR = &#39;anm-importer&#39;;

var $DE = {};

// FIXME: here are truly a lot of methods, try to
//        reduce their number as much as possible

// PX_RATIO

// require(what, func)
// define(id?, what, func)

// getRequestFrameFunc() -&gt; function(callback)
// getCancelFrameFunc() -&gt; function(id)

// ajax(url, callback?, errback?, method?, headers?) -&gt; none
// getCookie(name) -&gt; String
// onDocReady(callback) -&gt; none

// ensureGlobalStylesInjected() -&gt; none
// injectElementStyles(elm, general_class, instance_class) -&gt; [ general_rule, instance_rule ];

// createTextMeasurer() -&gt; function(text) -&gt; [ width, height ]

// getElementById(id) -&gt; Element
// findElementPosition(element) -&gt; [ x, y ]
// findScrollAwarePosition(eelementlm) -&gt; [ x, y ]
// // getElementBounds(element) -&gt; [ x, y, width, height, ratio ]
// moveElementTo(element, x, y) -&gt; none
// disposeElement(element) -&gt; none
// detachElement(parent | null, child) -&gt; none
// showElement(element) -&gt; none
// hideElement(element) -&gt; none
// clearChildren(element) -&gt; none

// assignPlayerToWrapper(wrapper, player, backup_id) -&gt; { wrapper, canvas, id }
// hasUrlToLoad(element) -&gt; { url, importer_id }
// extractUserOptions(element) -&gt; options: object | {}
// registerAsControlsElement(element, player) -&gt; none
// registerAsInfoElement(element, player) -&gt; none
// detachPlayer(player) -&gt; none
// playerAttachedTo(element, player) -&gt; true | false
// findPotentialPlayers() -&gt; [ element ]

// hasAnmProps(element) -&gt; object | null
// getAnmProps(element) -&gt; object
// clearAnmProps(element) -&gt; none

// createCanvas(width, height, bg?, ratio?) -&gt; canvas
// getContext(canvas, type) -&gt; context
// checkPlayerCanvas(canvas) -&gt; true | false
// setTabIndex(canvas) -&gt; none
// getCanvasSize(canvas) -&gt; [ width, height ]
// getCanvasPosition(canvas) -&gt; [ x, y ]
// getCanvasParameters(canvas) -&gt; [ width, height, ratio ]
// getCanvasBounds(canvas) -&gt; [ x, y, width, height, ratio ]
// setCanvasSize(canvas, width, height, ratio?) -&gt; none
// setCanvasPosisition(canvas, x, y) -&gt; none
// setCanvasBackground(canvas, value) -&gt; none
// addCanvasOverlay(id, parent: canvas, conf: [x, y, w, h], callback: function(canvas)) -&gt; canvas
// updateCanvasOverlays(canvas) -&gt; none
// updateOverlay(parent, overlay, props?) -&gt; none

// getEventPosition(event, element?) -&gt; [ x, y ]
// subscribeWindowEvents(handlers: object) -&gt; none
// subscribeCanvasEvents(canvas, handlers: object) -&gt; none
// unsubscribeCanvasEvents(canvas, handlers: object) -&gt; none
// subscribeAnimationToEvents(canvas, anim, map) -&gt; none
// unsubscribeAnimationFromEvents(canvas, anim) -&gt; none
// subscribeWrapperToStateChanges(wrapper, player) -&gt; none

// keyEvent(evt) -&gt; Event
// mouseEvent(evt, canvas) -&gt; Event//
// preventDefault(evt) -&gt; none

// createStyle() -&gt; Element
// createStatImg() -&gt; Image

// canvasSupported -&gt; bool

// Framing

$DE.__frameFunc = null;
$DE.__cancelFunc = null;
$DE.getRequestFrameFunc = function() {
    if ($DE.__frameFunc) return $DE.__frameFunc;
    return ($DE.__frameFunc =
                (window.requestAnimationFrame ||
                 window.webkitRequestAnimationFrame ||
                 window.mozRequestAnimationFrame ||
                 window.oRequestAnimationFrame ||
                 window.msRequestAnimationFrame ||
                 window.__anm__frameGen ||
                 function(callback){
                   return window.setTimeout(callback, 1000 / 60);
                 })) };
$DE.getCancelFrameFunc = function() {
    if ($DE.__cancelFunc) return $DE.__cancelFunc;
    return ($DE.__cancelFunc =
                (window.cancelAnimationFrame ||
                 window.webkitCancelAnimationFrame ||
                 window.mozCancelAnimationFrame ||
                 window.oCancelAnimationFrame ||
                 window.msCancelAnimationFrame ||
                 window.__anm__frameRem ||
                 function(id){
                   return window.clearTimeout(id);
                 })) };
/*$DE.stopAnim = function(reqId) {
    $DE.getCancelFrameFunc()(reqId);
}*/

// Global things

$DE.PX_RATIO = window.devicePixelRatio || 1;

$DE.ajax = function(url, callback, errback, method, headers) {
    var req = new window.XMLHttpRequest();

    if (!req) {
      throw new Error(&#39;Failed to create XMLHttp instance&#39;); // SysErr
    }

    var whenDone = function() {
        if (req.readyState == 4) {
            if (req.status == 200) {
                if (callback) callback(req);
            } else {
                var error = new Error(&#39;AJAX request for &#39; + url + // SysErr
                                 &#39; returned &#39; + req.status +
                                 &#39; instead of 200&#39;);
                if (errback) { errback(error, req); }
                else { throw error; }
            }
        }
    };

    req.onreadystatechange = whenDone;
    req.open(method || &#39;GET&#39;, url, true);

    if (headers) {
        for (var header in headers) {
            req.setRequestHeader(header, headers[header]);
        }
    }

    req.send(null);
}
$DE.getCookie = function(name) {
    // from http://www.codelib.net/javascript/cookies.html
    var s = $doc.cookie, i;
    if (s)
    for (i=0, s=s.split(&#39;; &#39;); i&lt;s.length; i++) {
    s[i] = s[i].split(&#39;=&#39;, 2);
    if (unescape(s[i][0]) == name)
    return unescape(s[i][1]);
    }
    return null;
    /*var val=RegExp(&quot;(\\b|;)&quot;+name+&quot;[^;\\b]+&quot;).exec($doc.cookie);
    return val ? unescape(val[0].replace(/^[^=]+./,&quot;&quot;)) : null;*/
}
$DE.onDocReady = function(callback) {
    //check if the document isn&#39;t already ready (sorry for the wording)
    if ($doc.readyState === &#39;complete&#39;) {
      callback();
      return;
    }
    var listener;
    if ($doc.addEventListener) {
        listener = $doc.addEventListener(&#39;DOMContentLoaded&#39;, function() {
            $doc.removeEventListener(&#39;DOMContentLoaded&#39;, listener, false);
            callback();
        }, false);
    } else if ($doc.attachEvent) {
        listener = $doc.attachEvent(&#39;onreadystatechange&#39;, function() {
            if ($doc.readyState === &#39;complete&#39;) {
                $doc.detachEvent(&#39;onreadystatechange&#39;, listener);
                callback();
            }
        });
    }
}

$DE.__stylesTag = null;
// FIXME: move these constants to anm.js
$DE.WRAPPER_CLASS = &#39;anm-wrapper&#39;;
$DE.WRAPPER_INSTANCE_CLASS_PREFIX = &#39;anm-wrapper-&#39;;
$DE.PLAYER_CLASS = &#39;anm-player&#39;;
$DE.PLAYER_INSTANCE_CLASS_PREFIX = &#39;anm-player-&#39;;
$DE.CONTROLS_CLASS = &#39;anm-controls&#39;;
$DE.CONTROLS_INSTANCE_CLASS_PREFIX = &#39;anm-controls-&#39;;
$DE.INFO_CLASS = &#39;anm-controls&#39;;
$DE.INFO_INSTANCE_CLASS_PREFIX = &#39;anm-controls-&#39;;

$DE.styling = {
    wrapperGeneral: function(rule) {
        rule.style.position = &#39;relative&#39;;
    },
    wrapperInstance: function(rule) { },
    playerGeneral: function(rule) { },
    playerInstance: function(rule, desc) { },
    controlsGeneral: function(rule) {
        rule.style.position = &#39;absolute&#39;;
        rule.style.left = 0;
        rule.style.top = 0;
        rule.style.verticalAlign = &#39;top&#39;;
        rule.style.zIndex = 100;
        rule.style.cursor = &#39;pointer&#39;;
        rule.style.backgroundColor = &#39;rgba(0, 0, 0, 0)&#39;;
    },
    controlsInstance: function(rule, desc) { },
    infoGeneral: function(rule) {
        rule.style.position = &#39;relative&#39;;
        rule.style.verticalAlign = &#39;top&#39;;
        rule.style.zIndex = 110;
        rule.style.cursor = &#39;pointer&#39;;
        rule.style.backgroundColor = &#39;rgba(0, 0, 0, 0)&#39;;
        rule.style.opacity = 1;
    },
    infoInstance: function(rule, desc) { },
}

$DE.ensureGlobalStylesInjected = function() {
    if ($DE.__stylesTag) return;
    //if (!($doc.readyState === &quot;complete&quot;)) return;
    var stylesTag = $DE.createStyle();
    stylesTag.type = &#39;text/css&#39;;

    // TODO: inject as first element?
    var head = $doc.getElementsByTagName(&quot;head&quot;)[0];
    if (!head) throw new Error(&#39;anm.Player requires &lt;head&gt; tag to exist in the document to inject CSS there&#39;);
    head.appendChild(stylesTag);
    // TODO: inject as first element?
    // var head = $doc.getElementsByTagName(&quot;head&quot;)[0];
    // head.insertBefore(stylesTag, head.firstChild);

    $DE.__stylesTag = stylesTag;
}
$DE.injectElementStyles = function(elm, general_class, instance_class) {
    var styles = $DE.__stylesTag.sheet,
        rules = styles.cssRules || styles.rules;
    if (elm.classList) {
        elm.classList.add(general_class);
        elm.classList.add(instance_class);
    } else if (elm.className){
        elm.className += general_class + &#39; &#39; + instance_class;
    } else {
        elm.className = general_class + &#39; &#39; + instance_class;
    }
    var props = $DE.getAnmProps(elm);
    props.gen_class  = general_class;
    props.inst_class = instance_class;
    var general_rule_idx  = (styles.insertRule || styles.addRule).call(styles, &#39;.&#39; +general_class + &#39;{}&#39;, rules.length),
        instance_rule_idx = (styles.insertRule || styles.addRule).call(styles, &#39;.&#39; +instance_class + &#39;{}&#39;, rules.length);
    var elm_rules = [ rules[general_rule_idx],
                      rules[instance_rule_idx] ];
    props.gen_rule  = elm_rules[0];
    props.inst_rule = elm_rules[1];
    return elm_rules;
}

$DE.__textBuf = null;
$DE.createTextMeasurer = function() {
    var buff = $DE.__textBuf;
    if (!buff) {
        /* FIXME: dispose buffer when text is removed from animation */
        $DE.onDocReady(function(){
          var div = $doc.createElement(&#39;div&#39;);
          var span = $doc.createElement(&#39;span&#39;);
          div.style.visibility = &#39;hidden&#39;;
          div.style.position = &#39;absolute&#39;;
          div.style.top = -10000 + &#39;px&#39;;
          div.style.left = -10000 + &#39;px&#39;;
          div.appendChild(span);
          $doc.body.appendChild(div);
          $DE.__textBuf = span;
          buff = $DE.__textBuf;
        });

    }
    return function(text, lines_arg) {
        var has_arg = (typeof lines_arg !== &#39;undefined&#39;);
        var lines = has_arg ? lines_arg : text.lines;
        buff.style.font = text.font;
        //buff.style.textAlign = text.align;
        //buff.style.verticalAlign = text.baseline || &#39;bottom&#39;;
        buff.style.whiteSpace = &#39;pre&#39;;
        if (Array.isArray(text.lines)) { // FIXME: replace with anm.is.arr()
            var maxWidth = 0, height = 0;
            for (var i = 0, ilen = lines.length; i &lt; ilen; i++) {
                buff.textContent = lines[i] || &quot; &quot;;
                maxWidth = Math.max(buff.offsetWidth, maxWidth);
                height += buff.offsetHeight;
            }
            return [ maxWidth, height ];
        } else {
            buff.textContent = text.lines.toString() || &quot;&quot;;
            return [ buff.offsetWidth,
                     buff.offsetHeight ];
        }
        // TODO: test if lines were changed, and if not,
        //       use cached value

    }
}

// Elements

$DE.getElementById = function(id) {
    return $doc.getElementById(id);
}
/* FIXME: replace with elm.getBoundingClientRect();
   see http://stackoverflow.com/questions/8070639/find-elements-position-in-browser-scroll */
// returns position on a screen, _including_ scroll
$DE.findElementPosition = function(elm) {
    if (elm.getBoundingClientRect) {
       var rect = elm.getBoundingClientRect();
       return [ rect.left, rect.top ];
    }
    var curleft = 0,
        curtop = 0;
    do {
        curleft += elm.offsetLeft;
        curtop += elm.offsetTop;
    } while (elm = elm.offsetParent);
    return [ curleft, curtop ];
}
$DE.findScrollAwarePosition = function(elm) {
    if (elm.getBoundingClientRect) {
        var curleft = 0,
            curtop = 0;
        var rect = elm.getBoundingClientRect();
        do {
            curleft += ((elm !== $doc.body)
                        ? elm.scrollLeft
                        : $doc.documentElement.scrollLeft);
            curtop += ((elm !== $doc.body)
                        ? elm.scrollTop
                        : $doc.documentElement.scrollTop);
        } while (elm = elm.offsetParent);
        return [ rect.left - curleft, rect.top - curtop ];
    }
    //var bound = elm.getBoundingClientRect();
    //return [ bound.left, bound.top ];
    var curleft = 0,
        curtop = 0;
    do {
        curleft += elm.offsetLeft - ((elm !== $doc.body)
                                     ? elm.scrollLeft
                                     : $doc.documentElement.scrollLeft);
        curtop += elm.offsetTop - ((elm !== $doc.body)
                                     ? elm.scrollTop
                                     : $doc.documentElement.scrollTop);
    } while (elm = elm.offsetParent);
    return [ curleft, curtop ];
}
/*$DE.getElementBounds = function(elm) {
    var rect = elm.getBoundingClientRect();
    return [ rect.left, rect.top, rect.width, rect.height, $DE.PX_RATIO ];
}*/
$DE.moveElementTo = function(elm, x, y) {
    var props = $DE.hasAnmProps(elm);
    ((props &amp;&amp; props.inst_rule) || elm).style.left = (x === 0) ? &#39;0&#39; : (x + &#39;px&#39;);
    ((props &amp;&amp; props.inst_rule) || elm).style.top  = (y === 0) ? &#39;0&#39; : (y + &#39;px&#39;);
}

$DE.__trashBin;
$DE.disposeElement = function(elm) {
    var trashBin = $DE.__trashBin;
    if (!trashBin) {
        trashBin = $doc.createElement(&#39;div&#39;);
        trashBin.id = &#39;trash-bin&#39;;
        trashBin.style.display = &#39;none&#39;;
        $doc.body.appendChild(trashBin);
        $DE.__trashBin = trashBin;
    }
    trashBin.appendChild(elm);
    trashBin.innerHTML = &#39;&#39;;
}
$DE.detachElement = function(parent, child) {
    (parent || child.parentNode).removeChild(child);
}
$DE.showElement = function(elm) {
    var props = $DE.hasAnmProps(elm);
    ((props &amp;&amp; props.inst_rule) || elm).style.visibility = &#39;visible&#39;;
}
$DE.hideElement = function(elm) {
    var props = $DE.hasAnmProps(elm);
    ((props &amp;&amp; props.inst_rule) || elm).style.visibility = &#39;hidden&#39;;
}
$DE.clearChildren = function(elm) {
    // much faster than innerHTML = &#39;&#39;;
    while (elm.firstChild) { elm.removeChild(elm.firstChild); }
}

// Creating &amp; Modifying Canvas

$DE.createCanvas = function(width, height, bg, ratio) {
    var cvs = $doc.createElement(&#39;canvas&#39;);
    $DE.setCanvasSize(cvs, width, height, ratio);
    if (bg) $DE.setCanvasBackground(cvs, bg);
    return cvs;
}
$DE.assignPlayerToWrapper = function(wrapper, player, backup_id) {
    if (!wrapper) throw new Error(&#39;Element passed to anm.Player initializer does not exists.&#39;);

    if (anm.utils.is.str(wrapper)) {
        wrapper = $doc.getElementById(wrapper);
    }

    var canvasWasPassed = (wrapper.tagName == &#39;canvas&#39;) || (wrapper.tagName == &#39;CANVAS&#39;);
    if (canvasWasPassed &amp;&amp; console) {
        (console.warn || console.log).call(console,
                     &#39;NB: A &lt;canvas&gt; tag was passed to the anm.Player as an element to attach to. This is &#39; +
                     &#39;not a recommended way since version 1.2; this &lt;canvas&gt; will be moved inside &#39; +
                     &#39;a &lt;div&gt;-wrapper because of it, so it may break document flow and/or CSS styles. &#39; +
                     &#39;Please pass any container such as &lt;div&gt; to a Player instead of &lt;canvas&gt; to fix it.&#39;);
    }

    var state_before = wrapper.cloneNode(false);

    var canvas = canvasWasPassed ? wrapper : $doc.createElement(&#39;canvas&#39;);
    wrapper = canvasWasPassed ? $doc.createElement(&#39;div&#39;) : wrapper;

    if (wrapper.getAttribute(MARKER_ATTR)) throw new Error(&#39;Player is already attached to element \&#39;&#39; + (wrapper.id || canvas.id) + &#39;\&#39;.&#39;);
    wrapper.setAttribute(MARKER_ATTR, true);
    if (wrapper.hasAttribute(AUTO_MARKER_ATTR)) wrapper.removeAttribute(AUTO_MARKER_ATTR);
    if (canvas.hasAttribute(AUTO_MARKER_ATTR))  canvas.removeAttribute(AUTO_MARKER_ATTR);

    var prev_cvs_id = canvas.id;
    canvas.id = &#39;&#39;; // to ensure no elements will have the same ID in DOM after the execution of next line
    if (!wrapper.id) wrapper.id = prev_cvs_id;
    canvas.id = wrapper.id + &#39;-cvs&#39;;
    var props = $DE.getAnmProps(canvas);
    props.wrapper = wrapper;
    props.was_before = state_before;

    var id = wrapper.id; // the &quot;main&quot; id

    props.id = id;

    if (canvasWasPassed) {
        var parent = canvas.parentNode || $doc.body;
        if (parent) {
            parent.replaceChild(wrapper, canvas);
            wrapper.appendChild(canvas);
        } else throw new Error(&#39;Provided canvas tag has no parent&#39;);
    } else {
        wrapper.appendChild(canvas);
    }

    $DE.ensureGlobalStylesInjected();

    var wrapper_rules = $DE.injectElementStyles(wrapper,
                                                $DE.WRAPPER_CLASS,
                                                $DE.WRAPPER_INSTANCE_CLASS_PREFIX + (id || &#39;no-id&#39;));
    var cvs_rules = $DE.injectElementStyles(canvas,
                                            $DE.PLAYER_CLASS,
                                            $DE.PLAYER_INSTANCE_CLASS_PREFIX + (id || &#39;no-id&#39;));

    $DE.styling.playerGeneral(cvs_rules[0]);
    $DE.styling.playerInstance(cvs_rules[1]);
    $DE.styling.wrapperGeneral(wrapper_rules[0]);
    $DE.styling.wrapperInstance(wrapper_rules[1]);

    $DE.subscribeWrapperToStateChanges(wrapper, player);

    return { wrapper: wrapper,
             canvas: canvas,
             id: id };
}
$DE.playerAttachedTo = function(elm, player) {
    if ($DE.hasAnmProps(elm)) { var props = $DE.getAnmProps(elm);
                                if (props.wrapper) return props.wrapper.hasAttribute(MARKER_ATTR); };
    return elm.hasAttribute(MARKER_ATTR);
}
$DE.findPotentialPlayers = function() {
    return $doc.querySelectorAll(&#39;[&#39; + AUTO_MARKER_ATTR + &#39;]&#39;);
}

$DE.hasAnmProps = function(elm) {
    return elm.__anm;
}
$DE.getAnmProps = function(elm) {
    if (!elm.__anm) elm.__anm = {};
    return elm.__anm;
}
$DE.clearAnmProps = function(elm) {
    if (!elm || !elm.__anm) return;
    var __anm = elm.__anm;
    if (__anm.gen_class &amp;&amp; __anm.inst_class) {
        var styles = $DE.__stylesTag.sheet,
            rules = styles.cssRules || styles.rules;
        var to_remove = [];
        for (var i = 0, il = rules.length; i &lt; il; i++) {
            if ((rules[i].selectorText == &#39;.&#39; + __anm.gen_class) ||
                (rules[i].selectorText == &#39;.&#39; + __anm.inst_class)) {
                to_remove.push(i); // not to conflict while iterating
            }
        }
        while (to_remove.length) { // remove from the end for safety
            (styles.deleteRule || styles.removeRule).call(styles, to_remove.pop());
        }
    }
    if (__anm.gen_class  &amp;&amp; elm.classList) elm.classList.remove(__anm.gen_class);
    if (__anm.inst_class &amp;&amp; elm.classList) elm.classList.remove(__anm.inst_class);
    delete elm.__anm;
}

$DE.detachPlayer = function(player) {
    var canvas = player.canvas,
        wrapper = player.wrapper;
    if (wrapper) wrapper.removeAttribute(MARKER_ATTR);
    var parent_node = wrapper.parentNode || $doc.body,
        next_node = wrapper.nextSibling;
    var props = $DE.getAnmProps(canvas);
    $DE.clearChildren(wrapper);
    if (props.was_before) {
        parent_node.removeChild(wrapper);
        parent_node.insertBefore(props.was_before, next_node);
    }
    $DE.clearAnmProps(wrapper);
    $DE.clearAnmProps(canvas);
    if (player.controls) {
        $DE.clearAnmProps(player.controls.canvas);
        if (player.controls.info) $DE.clearAnmProps(player.controls.info.canvas);
    }

    if (player.statImg) {
      $DE.detachElement(null, player.statImg);
    }
    //FIXME: should remove stylesTag when last player was deleted from page
    //$DE.detachElement(null, $DE.__stylesTag);
    //$DE.__stylesTag = null;
}
$DE.getContext = function(cvs, type) {
    return cvs.getContext(type);
}
$DE.extractUserOptions = function(elm) {

    function __boolAttr(val) {
        //if (val === undefined) return undefined;
        if (typeof val === &#39;undefined&#39;) return undefined;
        if (val === null) return null;
        if (val == &#39;0&#39;) return false;
        if (val == &#39;1&#39;) return true;
        if (val == &#39;false&#39;) return false;
        if (val == &#39;true&#39;) return true;
        if (val == &#39;off&#39;) return false;
        if (val == &#39;on&#39;) return true;
        if (val == &#39;no&#39;) return false;
        if (val == &#39;yes&#39;) return true;
    }

    var ratio = $DE.PX_RATIO;
    var width = elm.getAttribute(&#39;anm-width&#39;);
    if (!width) {
        width = elm.hasAttribute(&#39;width&#39;) ? (elm.getAttribute(&#39;width&#39;) / ratio)
                                          : undefined;
    }
    var height = elm.getAttribute(&#39;anm-height&#39;);
    if (!height) {
        height = elm.hasAttribute(&#39;height&#39;) ? (elm.getAttribute(&#39;height&#39;) / ratio)
                                            : undefined;
    }
    return { &#39;debug&#39;: __boolAttr(elm.getAttribute(&#39;anm-debug&#39;)),
             &#39;mode&#39;: elm.getAttribute(&#39;anm-mode&#39;),
             &#39;repeat&#39;: __boolAttr(elm.getAttribute(&#39;anm-repeat&#39;)),
             &#39;zoom&#39;: elm.getAttribute(&#39;anm-zoom&#39;),
             &#39;speed&#39;: elm.getAttribute(&#39;anm-speed&#39;),
             &#39;width&#39;: width,
             &#39;height&#39;: height,
             &#39;autoPlay&#39;: __boolAttr(elm.getAttribute(&#39;anm-autoplay&#39;) || elm.getAttribute(&#39;anm-auto-play&#39;)),
             &#39;bgColor&#39;: elm.getAttribute(&#39;anm-bgcolor&#39;) || elm.getAttribute(&#39;anm-bg-color&#39;),
             &#39;ribbonsColor&#39;: elm.getAttribute(&#39;anm-ribbons&#39;) || elm.getAttribute(&#39;anm-ribcolor&#39;) || elm.getAttribute(&#39;anm-rib-color&#39;),
             &#39;drawStill&#39;: __boolAttr(elm.getAttribute(&#39;anm-draw-still&#39;)
                                     || elm.getAttribute(&#39;anm-draw-thumbnail&#39;)
                                     || elm.getAttribute(&#39;anm-draw-thumb&#39;)),
             &#39;imagesEnabled&#39;: __boolAttr(elm.getAttribute(&#39;anm-images&#39;) || elm.getAttribute(&#39;anm-images-enabled&#39;)),
             &#39;shadowsEnabled&#39;: __boolAttr(elm.getAttribute(&#39;anm-shadows&#39;) || elm.getAttribute(&#39;anm-shadows-enabled&#39;)),
             &#39;audioEnabled&#39;: __boolAttr(elm.getAttribute(&#39;anm-audio&#39;) || elm.getAttribute(&#39;anm-audio-enabled&#39;)),
             &#39;controlsEnabled&#39;: __boolAttr(elm.getAttribute(&#39;anm-controls&#39;) || elm.getAttribute(&#39;anm-controls-enabled&#39;)),
             &#39;infoEnabled&#39;: __boolAttr(elm.getAttribute(&#39;anm-info&#39;) || elm.getAttribute(&#39;anm-info-enabled&#39;)),
             &#39;handleEvents&#39;: __boolAttr(elm.getAttribute(&#39;anm-events&#39;) || elm.getAttribute(&#39;anm-handle-events&#39;)),
             &#39;infiniteDuration&#39;: __boolAttr(elm.getAttribute(&#39;anm-infinite&#39;) || elm.getAttribute(&#39;anm-infinite-duration&#39;)),
             &#39;forceSceneSize&#39;: __boolAttr(elm.getAttribute(&#39;anm-scene-size&#39;) || elm.getAttribute(&#39;anm-force-scene-size&#39;)),
             &#39;inParent&#39;: undefined, // TODO: check if we&#39;re in tag?
             &#39;muteErrors&#39;: __boolAttr(elm.getAttribute(&#39;anm-mute-errors&#39;)),
             &#39;loadingMode&#39;: elm.getAttribute(&#39;anm-loading-mode&#39;),
             &#39;thumbnail&#39;: elm.getAttribute(&#39;anm-thumbnail&#39;)
           };
}
$DE.checkPlayerCanvas = function(cvs) {
    return true;
}
$DE.hasUrlToLoad = function(elm) {
    return {
        url: elm.getAttribute(URL_ATTR) || elm.getAttribute(SNAPSHOT_URL_ATTR),
        importer_id: elm.getAttribute(IMPORTER_ATTR)
    }
}
$DE.setTabIndex = function(cvs, idx) {
    cvs.setAttribute(&#39;tabindex&#39;, idx);
}
$DE.getCanvasParameters = function(cvs) {
    // if canvas size was not initialized by player, will return null
    if (!$DE.hasAnmProps(cvs)) return null;
    var props = $DE.getAnmProps(cvs);
    if (!props.width || !props.height) return null;
    return [ props.width, props.height, $DE.PX_RATIO ];
}
$DE.getCanvasSize = function(cvs) {
    if (cvs.getBoundingClientRect) {
       var rect = cvs.getBoundingClientRect();
       return [ rect.width, rect.height ];
    }
    return [ /* cvs.getAttribute(&#39;offsetWidth&#39;) || cvs.offsetWidth || */
             cvs.getAttribute(&#39;clientWidth&#39;) || cvs.clientWidth,
             /* cvs.getAttribute(&#39;offsetHeight&#39;) || cvs.offsetHeight || */
             cvs.getAttribute(&#39;clientHeight&#39;) || cvs.clientHeight ];
}
$DE.getCanvasPosition = function(cvs) {
    return $DE.findScrollAwarePosition(cvs);
}
$DE.getCanvasBounds = function(cvs/*, parent*/) {
    //var parent = parent || cvs.parentNode;
    var params = $DE.getCanvasParameters(cvs);
    if (!params) return null;
    var pos = $DE.getCanvasPosition(cvs);
    // bounds are: left, top, width, height, ratio.
    // I am not sure if I am correct in providing width/height instead of
    // left+width/top+height, but I think it&#39;s better to return values
    // not required to sum up/subtract in this case.
    return [ pos[0], pos[1], params[0], params[1], params[2] ];
}
$DE.setCanvasSize = function(cvs, width, height, ratio) {
    //$log.debug(&#39;request to resize canvas &#39; + (cvs.id || cvs) + &#39; to &#39; + width + &#39; &#39; + height);
    var ratio = ratio || $DE.PX_RATIO;
    var _w = width | 0, // to int
        _h = height | 0; // to int
    //$log.debug(&#39;resizing &#39; + (cvs.id || cvs) + &#39; to &#39; + _w + &#39; &#39; + _h);
    var props = $DE.getAnmProps(cvs);
    props.ratio = ratio;
    props.width = _w;
    props.height = _h;
    if (!cvs.style.width) { (props.inst_rule || cvs).style.width  = _w + &#39;px&#39;; }
    if (!cvs.style.height) { (props.inst_rule || cvs).style.height = _h + &#39;px&#39;; }
    cvs.setAttribute(&#39;width&#39;, _w * (ratio || 1));
    cvs.setAttribute(&#39;height&#39;, _h * (ratio || 1));
    $DE._saveCanvasPos(cvs);
    return [ _w, _h ];
}
$DE.setCanvasPosition = function(cvs, x, y) {
    var props = $DE.getAnmProps(cvs);
    props.usr_x = x;
    props.usr_y = y;
    // TODO: actually move canvas
    $DE._saveCanvasPos(cvs);
}
$DE.setCanvasBackground = function(cvs, bg) {
    ($DE.getAnmProps(cvs).inst_rule || cvs).style.backgroundColor = bg;
}
$DE._saveCanvasPos = function(cvs) {
    // FIXME: use getBoundingClientRect?
    var gcs = ($doc.defaultView &amp;&amp;
               $doc.defaultView.getComputedStyle); // last is assigned

    // computed padding-left
    var cpl = gcs ?
          (parseInt(gcs(cvs, null).paddingLeft, 10) || 0) : 0,
    // computed padding-top
        cpt = gcs ?
          (parseInt(gcs(cvs, null).paddingTop, 10) || 0) : 0,
    // computed border-left
        cbl = gcs ?
          (parseInt(gcs(cvs, null).borderLeftWidth,  10) || 0) : 0,
    // computed border-top
        cbt = gcs ?
          (parseInt(gcs(cvs, null).borderTopWidth,  10) || 0) : 0;

    var html = $doc.body.parentNode,
        htol = html.offsetLeft,
        htot = html.offsetTop;

    var elm = cvs,
        ol = cpl + cbl + htol,
        ot = cpt + cbt + htot;

    if (elm.offsetParent !== undefined) {
        do {
            ol += elm.offsetLeft;
            ot += elm.offsetTop;
        } while (elm = elm.offsetParent)
    }

    ol += cpl + cbl + htol;
    ot += cpt + cbt + htot;

    /* FIXME: find a method with no injection of custom properties
              (data-xxx attributes are stored as strings and may work
               a bit slower for events) */
    // FIXME: NOT USED ANYMORE
    var props = $DE.getAnmProps(cvs);
    props.offset_left = ol || props.usr_x;
    props.offset_top  = ot || props.usr_y;
}
$DE.addCanvasOverlay = function(id, player_cvs, conf, callback) {
    // conf should be: [ x, y, w, h ], all in percentage relative to parent
    // style may contain _class attr
    // if (!parent) throw new Error();
    var p_props = $DE.getAnmProps(player_cvs);
    var holder = p_props.wrapper || player_cvs.parentNode || $doc.body;
    var x = conf[0], y = conf[1],
        w = conf[2], h = conf[3];
    var pconf = $DE.getCanvasSize(player_cvs),
        pw = pconf[0], ph = pconf[1];
    var p_style = window.getComputedStyle ? window.getComputedStyle(player_cvs) : player_cvs.currentStyle;
    var x_shift = parseFloat(p_style.getPropertyValue(&#39;border-left-width&#39;)),
        y_shift = parseFloat(p_style.getPropertyValue(&#39;border-top-width&#39;));
    var new_w = (w * pw),
        new_h = (h * ph);
    var cvs = $doc.createElement(&#39;canvas&#39;);
    cvs.id = (p_props.id) ? (&#39;__&#39; + p_props.id + &#39;_&#39; + id) : (&#39;__anm_&#39; + id);
    var props = $DE.getAnmProps(cvs);
    if (callback) callback(cvs, player_cvs);
    $DE.setCanvasSize(cvs, new_w, new_h);
    var new_x = (x * new_w) + x_shift,
        new_y = (y * new_h) - y_shift;
    $DE.moveElementTo(cvs, new_x, new_y);
    // .insertBefore() in combination with .nextSibling works as .insertAfter() simulation
    (holder || $doc.body).insertBefore(cvs, player_cvs.nextSibling);
    props.ref_canvas = player_cvs;
    if (!p_props.overlays) p_props.overlays = [];
    p_props.overlays.push(cvs);
    return cvs;
}
$DE.updateCanvasOverlays = function(player_cvs) {
    var p_props = $DE.getAnmProps(player_cvs);
    var overlays = p_props.overlays;
    if (overlays) { for (var i = 0, il = overlays.length; i &lt; il; i++) {
        $DE.updateOverlay(player_cvs, overlays[i], p_props);
    } }
}
$DE.updateOverlay = function(player_cvs, overlay, p_props) {
    var p_props = p_props || $DE.getAnmProps(player_cvs);
    $DE.setCanvasSize(overlay, p_props.width, p_props.height);
}

// Controls &amp; Info

$DE.registerAsControlsElement = function(elm, player) {
    var rules = $DE.injectElementStyles(elm,
                                $DE.CONTROLS_CLASS,
                                $DE.CONTROLS_INSTANCE_CLASS_PREFIX + (player.id || &#39;no-id&#39;));
    $DE.styling.controlsGeneral(rules[0]);
    $DE.styling.controlsInstance(rules[1]);
}
$DE.registerAsInfoElement = function(elm, player) {
    var rules = $DE.injectElementStyles(elm,
                                $DE.INFO_CLASS,
                                $DE.INFO_INSTANCE_CLASS_PREFIX + (player.id || &#39;no-id&#39;));
    $DE.styling.infoGeneral(rules[0]);
    $DE.styling.infoInstance(rules[1]);
}

// Events

$DE.getEventPosition = function(evt, elm) {
    /*if (elm &amp;&amp; (elm.__rOffsetLeft || elm.__rOffsetTop)) return [ evt.pageX - elm.__rOffsetLeft,
                                                                 evt.pageY - elm.__rOffsetTop ];
    else */ if (elm) {
        var shift = $DE.findElementPosition(elm); // $DE.findScrollAwarePosition(elm);
        return [ evt.x - shift[0], evt.y - shift[1] ];
    } else return [ evt.x, evt.y ];
}
$DE.subscribeWindowEvents = function(handlers) {
    for (var type in handlers) {
        window.addEventListener(type, handlers[type], false);
    }
}
$DE.subscribeCanvasEvents = function(cvs, handlers) {
    for (var type in handlers) {
        cvs.addEventListener(type, handlers[type], false);
    }
}
$DE.unsubscribeCanvasEvents = function(cvs, handlers) {
    for (var type in handlers) {
        cvs.removeEventListener(type, handlers[type]);
    }
}
$DE.keyEvent = function(e) {
    return { key: ((e.keyCode != null) ? e.keyCode : e.which),
             ch: e.charCode };
}
$DE.mouseEvent = function(e, cvs) {
    return { pos: $DE.getEventPosition(e, cvs) };
}
$DE.preventDefault = function(evt) {
    evt.stopPropagation();
    evt.preventDefault();
}
var _kevt = $DE.keyEvent,
    _mevt = $DE.mouseEvent;
$DE.subscribeAnimationToEvents = function(cvs, anim, map) {
    if (cvs.__anm.subscribed &amp;&amp;
        cvs.__anm.subscribed[anim.id]) {
        return;
    }
    //cvs.__anm_subscription_id = guid();
    if (!cvs.__anm.handlers)   cvs.__anm.handlers = {};
    if (!cvs.__anm.subscribed) cvs.__anm.subscribed = {};
    var handlers = cvs.__anm.subscribed[anim.id] || {
      mouseup:   function(evt) { anim.fire(map.mouseup,   _mevt(evt, cvs)); },
      mousedown: function(evt) { anim.fire(map.mousedown, _mevt(evt, cvs)); },
      mousemove: function(evt) { anim.fire(map.mousemove, _mevt(evt, cvs)); },
      mouseover: function(evt) { anim.fire(map.mouseover, _mevt(evt, cvs)); },
      mouseout:  function(evt) { anim.fire(map.mouseout,  _mevt(evt, cvs)); },
      click:     function(evt) { anim.fire(map.click,     _mevt(evt, cvs)); },
      dblclick:  function(evt) { anim.fire(map.dblclick,  _mevt(evt, cvs)); },
      keyup:     function(evt) { anim.fire(map.keyup,     _kevt(evt)); },
      keydown:   function(evt) { anim.fire(map.keydown,   _kevt(evt)); },
      keypress:  function(evt) { anim.fire(map.keypress,  _kevt(evt)); }
    };
    cvs.__anm.handlers[anim.id] = handlers;
    cvs.__anm.subscribed[anim.id] = true;
    $DE.subscribeCanvasEvents(cvs, handlers);
}
$DE.unsubscribeAnimationFromEvents = function(cvs, anim) {
    if (!cvs.__anm.handlers   ||
        !cvs.__anm.subscribed ||
        !cvs.__anm.subscribed[anim.id]) return;
    var handlers = cvs.__anm.handlers[anim.id];
    if (!handlers) return;
    $DE.unsubscribeCanvasEvents(cvs, handlers);
}
$DE.subscribeWrapperToStateChanges = function(wrapper, player) {
    if (!wrapper.classList) return;
    var C = anm.constants;
    player.on(C.S_CHANGE_STATE, function(new_state) {
        var css_classes = [];
        switch (new_state) {
            case C.NOTHING: css_classes = [&#39;anm-state-nothing&#39;]; break;
            case C.STOPPED: css_classes = [&#39;anm-state-stopped&#39;]; break;
            case C.PLAYING: css_classes = [&#39;anm-state-playing&#39;]; break;
            case C.PAUSED:  css_classes = [&#39;anm-state-paused&#39;]; break;
            case C.LOADING: css_classes = [&#39;anm-state-loading&#39;]; break;
            case C.RES_LOADING: css_classes = [&#39;anm-state-loading&#39;, &#39;anm-state-resources-loading&#39;]; break;
            case C.ERROR:   css_classes = [&#39;anm-state-error&#39;]; break;
        }
        if (css_classes.length) {
            var classList = wrapper.classList;
            if (player.__prev_classes &amp;&amp; player.__prev_classes.length) {
                var prev_classes = player.__prev_classes;
                for (var i = 0, il = prev_classes.length; i &lt; il; i++) {
                    classList.remove(prev_classes[i]);
                }
            } else {
                if (classList.contains(&#39;anm-state-nothing&#39;)) {
                    classList.remove(&#39;anm-state-nothing&#39;);
                }
            }
            for (var i = 0, il = css_classes.length; i &lt; il; i++) {
                classList.add(css_classes[i]);
            }
            player.__prev_classes = css_classes;
        }
    });
};

$DE.createStatImg = function() {
    var img = $doc.createElement(&#39;img&#39;);
    img.style.position = &#39;absolute&#39;;
    img.style.top = &#39;-9999px&#39;;
    img.style.left = &#39;-9999px&#39;;
    img.style.visibility = &#39;hidden&#39;;

    $doc.body.appendChild(img);

    return img;
};

$DE.createStyle = function() {
    return document.createElement(&#39;style&#39;);
};

$DE.createAudio = function() {
    return document.createElement(&#39;audio&#39;);
}

$DE.createSource = function() {
    return document.createElement(&#39;source&#39;);
}

$DE.appendToBody = function(element) {
    document.body.appendChild(element);
}

var testCanvas = document.createElement(&#39;canvas&#39;);
$DE.canvasSupported = !!(testCanvas.getContext &amp;&amp; testCanvas.getContext(&#39;2d&#39;));


module.exports = $DE;
return $DE;
</pre>
</body>
</html>
