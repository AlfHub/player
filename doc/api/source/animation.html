<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var C = require(&#39;../constants.js&#39;),
    engine = require(&#39;engine&#39;),
    Element = require(&#39;./element.js&#39;),
    Clip = Element,
    Brush = require(&#39;../graphics/brush.js&#39;),
    provideEvents = require(&#39;../events.js&#39;).provideEvents,
    AnimationError = require(&#39;../errors.js&#39;).AnimationError,
    Errors = require(&#39;../loc.js&#39;).Errors,
    ResMan = require(&#39;../resource_manager.js&#39;),
    FontDetector = require(&#39;../../vendor/font_detector.js&#39;),
    utils = require(&#39;../utils.js&#39;),
    is = utils.is,
    iter = utils.iter;


/* X_ERROR, X_FOCUS, X_RESIZE, X_SELECT, touch events */

var DOM_TO_EVT_MAP = {
  &#39;mouseup&#39;:   C.X_MUP,
  &#39;mousedown&#39;: C.X_MDOWN,
  &#39;mousemove&#39;: C.X_MMOVE,
  &#39;mouseover&#39;: C.X_MOVER,
  &#39;mouseout&#39;:  C.X_MOUT,
  &#39;click&#39;:     C.X_MCLICK,
  &#39;dblclick&#39;:  C.X_MDCLICK,
  &#39;keyup&#39;:     C.X_KUP,
  &#39;keydown&#39;:   C.X_KDOWN,
  &#39;keypress&#39;:  C.X_KPRESS
};

// Animation
// -----------------------------------------------------------------------------

<span id='anm-Animation-method-constructor'><span id='anm-Animation'>/**
</span></span> * @class anm.Animation
 *
 * Create an Animation.
 *
 * It holds an elements tree, an id-to-element map, background fill, zoom and
 * repeat option. It also may render itself to any context with {@link anm.Animation#render}
 * method.
 *
 * Use {@link anm.Animation#add()} to add elements to an animation.
 *
 * Use {@link anm.Animation#find()} / {@link anm.Animation#findById()} to search for elements in the animation.
 *
 * Use {@link anm.Animation#each()} / {@link anm.Animation#traverse()} to loop through all direct child elements
 * or through the whole tree of children, correspondingly.
 *
 * See {@link anm.Element Element} for detailed description of the basic &quot;brick&quot; of any animation.
 *
 * @constructor
 */
function Animation() {
    this.id = utils.guid();
    this.tree = [];
    this.hash = {};
    this.name = &#39;&#39;;
    this.duration = undefined;
    this.bgfill = null;
    this.width = undefined;
    this.height = undefined;
    this.zoom = 1.0;
    this.speed = 1.0;
    this.repeat = false;
    this.meta = {};
    //this.fps = undefined;
    this.__informEnabled = true;
    this._laters = [];
    this._initHandlers(); // TODO: make automatic
}

Animation.DEFAULT_DURATION = 10;

// mouse/keyboard events are assigned in L.loadAnimation
/* TODO: move them into animation */
provideEvents(Animation, [ C.X_MCLICK, C.X_MDCLICK, C.X_MUP, C.X_MDOWN,
                           C.X_MMOVE, C.X_MOVER, C.X_MOUT,
                           C.X_KPRESS, C.X_KUP, C.X_KDOWN,
                           C.X_DRAW,
                           // player events
                           C.S_CHANGE_STATE,
                           C.S_PLAY, C.S_PAUSE, C.S_STOP, C.S_COMPLETE, C.S_REPEAT,
                           C.S_IMPORT, C.S_LOAD, C.S_RES_LOAD, C.S_ERROR ]);
<span id='anm-Animation-method-add'>/**
</span> * @method add
 * @chainable
 *
 * Append one or several {@link anm.Element elements} to this animation.
 *
 * May be used as:
 *
 * * `anim.add(new anm.Element());`
 * * `anim.add([new anm.Element(), new anm.Element()]);`
 * * `anim.add(function(ctx) {...}, function(t) { ... });`
 * * `anim.add(function(ctx) {...}, function(t) { ... },
 *           function(ctx, prev(ctx)) { ... });`
 *
 * @param {anm.Element|anm.Clip|Array[Element]} subject Any number of Elements to add
 *
 * @return {anm.Element} The Element was appended.
 *
 */
Animation.prototype.add = function(arg1, arg2, arg3) {
    // this method only adds an element to a top-level
    // FIXME: allow to add elements deeper or rename this
    //        method to avoid confusion?
    if (arg2) { // element by functions mode
        var elm = new Element(arg1, arg2);
        if (arg3) elm.changeTransform(arg3);
        this.addToTree(elm);
        //return elm;
    } else if (is.arr(arg1)) { // elements array mode
        var clip = new Clip();
        clip.add(arg1);
        this.addToTree(_clip);
        //return clip;
    } else { // element object mode
        this.addToTree(arg1);
    }
    return this;
}
/* addS allowed to add static element before, such as image, may be return it in some form? */
<span id='anm-Animation-method-remove'>/**
</span> * @method remove
 * @chainable
 *
 * Remove (unregister) element from this animation.
 *
 * @param {anm.Element} element
 */
Animation.prototype.remove = function(elm) {
    // error will be thrown in _unregister method
    //if (!this.hash[elm.id]) throw new AnimErr(Errors.A.ELEMENT_IS_NOT_REGISTERED);
    if (elm.parent) {
        // it will unregister element inside
        elm.parent.remove(elm);
    } else {
        this._unregister(elm);
    }
    return this;
}
// &gt; Animation.prototype.clear % ()
/* Animation.prototype.clear = function() {
    this.hash = {};
    this.tree = [];
    this.duration = 0;
    var hash = this.hash;
    this.hash = {};
    for (var elmId in hash) {
        hash[elm.id]._unbind(); // unsafe, because calls unregistering
    }
} */
<span id='anm-Animation-method-traverse'>/**
</span> * @method traverse
 * @chainable
 *
 * Visit every element in a tree, no matter how deep it is.
 *
 * @param {Function} visitor
 * @param {anm.Element} visitor.element
 * @param {Object} [data]
 */
// visitElems
Animation.prototype.traverse = function(visitor, data) {
    for (var elmId in this.hash) {
        visitor(this.hash[elmId], data);
    }
    return this;
}
<span id='anm-Animation-method-each'>/**
</span> * @method each
 * @chainable
 *
 * Visit every root element (direct Animation child) in a tree.
 *
 * @param {Function} visitor
 * @param {anm.Element} visitor.child
 * @param {Object} [data]
 */
Animation.prototype.each = function(visitor, data) {
    for (var i = 0, tlen = this.tree.length; i &lt; tlen; i++) {
        visitor(this.tree[i], data);
    }
    return this;
}
<span id='anm-Animation-method-iter'>/**
</span> * @method iter
 * @chainable
 *
 * Iterate through every root (direct Animation child) element in a tree.
 *
 * @param {Function} iterator
 * @param {anm.Element} iterator.child
 * @param {Boolean} iterator.return `false`, if this element should be removed
 */
Animation.prototype.iter = function(func, rfunc) {
    iter(this.tree).each(func, rfunc);
    return this;
}
<span id='anm-Animation-method-render'>/**
</span> * @method render
 *
 * Render the Animation for given context at given time.
 *
 * @param {Canvas2DContext} context
 * @param {Number} time
 * @param {Number} [dt] The difference in time between current frame and previous one
 */
Animation.prototype.render = function(ctx, time, dt) {
    ctx.save();
    var zoom = this.zoom;
    try {
        if (zoom != 1) {
            ctx.scale(zoom, zoom);
        }
        if (this.bgfill) {
            if (!this.bgfill instanceof Brush) this.bgfill = Brush.fill(this.bgfill);
            ctx.fillStyle = this.bgfill.apply(ctx);
            ctx.fillRect(0, 0, this.width, this.height);
        }
        this.each(function(child) {
            child.render(ctx, time, dt);
        });
    } finally { ctx.restore(); }
    this.fire(C.X_DRAW,ctx);
}
Animation.prototype.handle__x = function(type, evt) {
    this.traverse(function(elm) {
        elm.fire(type, evt);
    });
    return true;
}
// TODO: test
<span id='anm-Animation-method-getFittingDuration'>/**
</span> * @method getFittingDuration
 *
 * Get the duration where all child elements&#39; bands fit.
 *
 * @return {Number} The calculated duration
 */
Animation.prototype.getFittingDuration = function() {
    var max_pos = -Infinity;
    var me = this;
    this.each(function(child) {
        var elm_tpos = child._max_tpos();
        if (elm_tpos &gt; max_pos) max_pos = elm_tpos;
    });
    return max_pos;
}
<span id='anm-Animation-method-reset'>/**
</span> * @method reset
 * @chainable
 *
 * Reset all render-related data for itself, and the data of all the elements.
 */
Animation.prototype.reset = function() {
    this.__informEnabled = true;
    this.each(function(child) {
        child.reset();
    });
    return this;
}
<span id='anm-Animation-method-dispose'>/**
</span> * @method dispose
 * @chainable
 *
 * Remove every possible allocated data to either never use this animation again or
 * start using it from scratch as if it never was used before.
 */
Animation.prototype.dispose = function() {
    this.disposeHandlers();
    var me = this;
    /* FIXME: unregistering removes from tree, ensure it is safe */
    this.iter(function(child) {
        me._unregister_no_rm(child);
        child.dispose();
        return false;
    });
    return this;
}
<span id='anm-Animation-method-isEmpty'>/**
</span> * @method isEmpty
 *
 * Does Animation has any Elements inside.
 *
 * @return {Boolean} `true` if no Elements, `false` if there are some.
 */
Animation.prototype.isEmpty = function() {
    return this.tree.length == 0;
}
<span id='anm-Animation-method-toString'>/**
</span> * @method toString
 *
 * Get a pretty description of this Animation
 *
 * @return {String} pretty string
 */
Animation.prototype.toString = function() {
    return &quot;[ Animation &quot;+(this.name ? &quot;&#39;&quot;+this.name+&quot;&#39;&quot; : &quot;&quot;)+&quot;]&quot;;
}
<span id='anm-Animation-method-subscribeEvents'>/**
</span> * @method subscribeEvents
 * @private
 *
 * @param {Canvas} canvas
 */
Animation.prototype.subscribeEvents = function(canvas) {
    engine.subscribeAnimationToEvents(canvas, this, DOM_TO_EVT_MAP);
}
<span id='anm-Animation-method-unsubscribeEvents'>/**
</span> * @method unsubscribeEvents
 * @private
 *
 * @param {Canvas} canvas
 */
Animation.prototype.unsubscribeEvents = function(canvas) {
    engine.unsubscribeAnimationFromEvents(canvas, this);
}
<span id='anm-Animation-method-addToTree'>/**
</span> * @method addToTree
 * @private
 *
 * @param {anm.Element} element
 */
Animation.prototype.addToTree = function(elm) {
    if (!elm.children) {
        throw new AnimationError(&#39;It appears that it is not a clip object or element that you pass&#39;);
    }
    this._register(elm);
    /*if (elm.children) this._addElems(elm.children);*/
    this.tree.push(elm);
}
/*Animation.prototype._addElems = function(elems) {
    for (var ei = 0; ei &lt; elems.length; ei++) {
        var _elm = elems[ei];
        this._register(_elm);
    }
}*/
Animation.prototype._register = function(elm) {
    if (this.hash[elm.id]) throw new AnimationError(Errors.A.ELEMENT_IS_REGISTERED);
    elm.registered = true;
    elm.anim = this;
    this.hash[elm.id] = elm;
    var me = this;
    elm.each(function(child) {
        me._register(child);
    });
}
Animation.prototype._unregister_no_rm = function(elm) {
    this._unregister(elm, true);
}
Animation.prototype._unregister = function(elm, save_in_tree) { // save_in_tree is optional and false by default
    if (!elm.registered) throw new AnimationError(Errors.A.ELEMENT_IS_NOT_REGISTERED);
    var me = this;
    elm.each(function(child) {
        me._unregister(child);
    });
    var pos = -1;
    if (!save_in_tree) {
      while ((pos = this.tree.indexOf(elm)) &gt;= 0) {
        this.tree.splice(pos, 1); // FIXME: why it does not goes deeply in the tree?
      }
    }
    delete this.hash[elm.id];
    elm.registered = false;
    elm.anim = null;
    //elm.parent = null;
}
Animation.prototype._collectRemoteResources = function(player) {
    var remotes = [],
        anim = this;
    this.traverse(function(elm) {
        if (elm._hasRemoteResources(anim, player)) {
           remotes = remotes.concat(elm._collectRemoteResources(anim, player)/* || []*/);
        }
    });
    if(this.fonts &amp;&amp; this.fonts.length) {
        remotes = remotes.concat(this.fonts.map(function(f){return f.url;}));
    }
    return remotes;
}
Animation.prototype._loadRemoteResources = function(player) {
    var anim = this;
    this.traverse(function(elm) {
        if (elm._hasRemoteResources(anim, player)) {
           elm._loadRemoteResources(anim, player);
        }
    });
    anim.loadFonts(player);
}
<span id='anm-Animation-method-find'>/**
</span> * @method find
 *
 * Searches for {@link anm.Element elements} by name inside another
 * {@link anm.Element element} or inside the whole Animation itself, if no other
 * element was provided.
 *
 * NB: `find` method will be improved soon to support special syntax of searching,
 * so you will be able to search almost everything
 *
 * @param {String} name Name of the element(s) to find
 * @param {anm.Element} [where] Where to search elements for; if omitted, searches in Animation
 *
 * @return {Array} An array of found elements
 */
Animation.prototype.find = function(name, where) {
    var where = where || this;
    var found = [];
    if (where.name == name) found.push(name);
    where.traverse(function(elm)  {
        if (elm.name == name) found.push(elm);
    });
    return found;
}
<span id='anm-Animation-method-findById'>/**
</span> * @method findById
 *
 * Searches for {@link anm.Element elements} by ID inside another inside the
 * Animation. Actually, just gets it from hash map, so O(1).
 *
 * @param {String} id ID of the element to find
 * @return {anm.Element|Null} An element you&#39;ve searched for, or null
 *
 * @deprecated in favor of special syntax in `find` method
 */
Animation.prototype.findById = function(id) {
    return this.hash[id];
}
/*
 * @method invokeAllLaters
 * @private
 */
Animation.prototype.invokeAllLaters = function() {
    for (var i = 0; i &lt; this._laters.length; i++) {
        this._laters[i].call(this);
    };
}
/*
 * @method clearAllLaters
 * @private
 */
Animation.prototype.clearAllLaters = function() {
    this._laters = [];
}
/*
 * @method invokeLater
 * @private
 */
Animation.prototype.invokeLater = function(f) {
    this._laters.push(f);
}

var FONT_LOAD_TIMEOUT = 10000; //in ms
/*
 * @method loadFonts
 * @private
 */
Animation.prototype.loadFonts = function(player) {
    if (!this.fonts || !this.fonts.length) {
        return;
    }

    var fonts = this.fonts,
        style = engine.createStyle(),
        css = &#39;&#39;,
        fontsToLoad = [],
        detector = new FontDetector();
    style.type = &#39;text/css&#39;;

    for (var i = 0; i &lt; fonts.length; i++) {
        var font = fonts[i];
        if (!font.url || !font.face || detector.detect(font.face)) {
            //no font name or url || font already available
            continue;
        }
        fontsToLoad.push(font);
        css += &#39;@font-face {&#39; +
            &#39;font-family: &quot;&#39; + font.face + &#39;&quot;; &#39; +
            &#39;src:&#39; +  (font.woff ? &#39;url(&quot;&#39;+font.woff+&#39;&quot;) format(&quot;woff&quot;), &#39; : &#39;&#39;) +
            &#39;url(&quot;&#39;+font.url+&#39;&quot;);&#39; +
            (font.style ? &#39;style: &#39; + font.style +&#39;; &#39; : &#39;&#39;) +
            (font.weight ? &#39;weight: &#39; + font.weight + &#39;; &#39; : &#39;&#39;) +
            &#39;}\n&#39;;
    }

    if (fontsToLoad.length == 0) {
        return;
    };

    style.innerHTML = css;
    document.head.appendChild(style); // FIXME: should use engine

    for (var i = 0; i &lt; fontsToLoad.length; i++) {
        // FIXME: should not require a player (probably)
        ResMan.loadOrGet(player.id, fontsToLoad[i].url, function(success) {
            var face = fontsToLoad[i].face,
                interval = 100,
                counter = 0,
                intervalId,
                checkLoaded = function() {
                    counter += interval;
                    var loaded = detector.detect(face);
                    if (loaded || counter &gt; FONT_LOAD_TIMEOUT) {
                    // after 10 seconds, we&#39;ll just assume the font has been loaded
                    // and carry on. this should help when the font could not be
                    // reached for whatever reason.
                        clearInterval(intervalId);
                        success();
                    }
                };
            intervalId = setInterval(checkLoaded, interval)
        });
    }

};

module.exports = Animation;
</pre>
</body>
</html>
