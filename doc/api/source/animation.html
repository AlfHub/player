<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var utils = require(&#39;../utils.js&#39;),
    is = utils.is,
    iter = utils.iter,
    C = require(&#39;../constants.js&#39;);

var engine = require(&#39;engine&#39;),
    ResMan = require(&#39;../resource_manager.js&#39;),
    FontDetector = require(&#39;../../vendor/font_detector.js&#39;);

var Element = require(&#39;./element.js&#39;),
    Clip = Element,
    Brush = require(&#39;../graphics/brush.js&#39;);

var events = require(&#39;../events.js&#39;),
    provideEvents = events.provideEvents,
    errors = require(&#39;../errors.js&#39;),
    ErrLoc = require(&#39;../loc.js&#39;).Errors;


/* X_ERROR, X_FOCUS, X_RESIZE, X_SELECT, touch events */

var DOM_TO_EVT_MAP = {
    &#39;click&#39;:     C.X_MCLICK,
    &#39;dblclick&#39;:  C.X_MDCLICK,
    &#39;mouseup&#39;:   C.X_MUP,
    &#39;mousedown&#39;: C.X_MDOWN,
    &#39;mousemove&#39;: C.X_MMOVE,
    &#39;mouseover&#39;: C.X_MOVER,
    &#39;mouseout&#39;:  C.X_MOUT,
    &#39;keypress&#39;:  C.X_KPRESS,
    &#39;keyup&#39;:     C.X_KUP,
    &#39;keydown&#39;:   C.X_KDOWN
};

// Animation
// -----------------------------------------------------------------------------

<span id='anm-Animation-method-constructor'><span id='anm-Animation'>/**
</span></span> * @class anm.Animation
 *
 * Create an Animation.
 *
 * It holds an elements tree, an id-to-element map, background fill, zoom and
 * repeat option. It also may render itself to any context with {@link anm.Animation#render}
 * method.
 *
 * Use {@link anm.Animation#add} to add elements to an animation.
 *
 * Use {@link anm.Animation#find} / {@link anm.Animation#findById} to search for elements in the animation.
 *
 * Use {@link anm.Animation#each} / {@link anm.Animation#traverse} to loop through all direct child elements
 * or through the whole tree of children, correspondingly.
 *
 * See {@link anm.Element Element} for detailed description of the basic &quot;brick&quot; of any animation.
 *
 * @constructor
 */
function Animation() {
    this.id = utils.guid();
    this.tree = [];
    this.hash = {};
    this.name = &#39;&#39;;
    this.duration = undefined;
    this.bgfill = null;
    this.width = undefined;
    this.height = undefined;
    this.zoom = 1.0;
    this.speed = 1.0;
    this.repeat = false;
    this.meta = {};
    this.hasScripting = false;
    this.targets = {}; // Player instances where this animation was loaded, by ID
    //this.fps = undefined;
    this.__informEnabled = true;
    this._laters = [];
    this._initHandlers(); // TODO: make automatic
}

Animation.DEFAULT_DURATION = 10;

provideEvents(Animation, [ C.A_START, C.A_PAUSE, C.A_STOP,
                           C.X_MCLICK, C.X_MDCLICK, C.X_MUP, C.X_MDOWN,
                           C.X_MMOVE, C.X_MOVER, C.X_MOUT,
                           C.X_KPRESS, C.X_KUP, C.X_KDOWN, C.X_ERROR ]);
<span id='anm-Animation-method-add'>/**
</span> * @method add
 * @chainable
 *
 * Append one or several {@link anm.Element elements} to this animation.
 *
 * May be used as:
 *
 * * `anim.add(new anm.Element());`
 * * `anim.add([new anm.Element(), new anm.Element()]);`
 * * `anim.add(function(ctx) {...}, function(t) { ... });`
 * * `anim.add(function(ctx) {...}, function(t) { ... },
 *           function(ctx, prev(ctx)) { ... });`
 *
 * @param {anm.Element|anm.Clip|Array[Element]} subject Any number of Elements to add
 *
 * @return {anm.Element} The Element was appended.
 *
 */
Animation.prototype.add = function(arg1, arg2, arg3) {
    // this method only adds an element to a top-level
    // FIXME: allow to add elements deeper or rename this
    //        method to avoid confusion?
    if (arg2) { // element by functions mode
        var elm = new Element(arg1, arg2);
        if (arg3) elm.changeTransform(arg3);
        this.addToTree(elm);
        //return elm;
    } else if (is.arr(arg1)) { // elements array mode
        var clip = new Clip();
        clip.add(arg1);
        this.addToTree(_clip);
        //return clip;
    } else { // element object mode
        this.addToTree(arg1);
    }
    return this;
};

<span id='anm-Animation-method-remove'>/**
</span> * @method remove
 * @chainable
 *
 * Remove (unregister) element from this animation.
 *
 * @param {anm.Element} element
 */
Animation.prototype.remove = function(elm) {
    // error will be thrown in _unregister method if element is not registered
    if (elm.parent) {
        // it will unregister element inside
        elm.parent.remove(elm);
    } else {
        this._unregister(elm);
    }
    return this;
};

<span id='anm-Animation-method-traverse'>/**
</span> * @method traverse
 * @chainable
 *
 * Visit every element in a tree, no matter how deep it is.
 *
 * @param {Function} visitor
 * @param {anm.Element} visitor.element
 * @param {Object} [data]
 */
Animation.prototype.traverse = function(visitor, data) {
    utils.keys(this.hash, function(key, elm) { visitor(elm, data); });
    return this;
};

<span id='anm-Animation-method-each'>/**
</span> * @method each
 * @chainable
 *
 * Visit every root element (direct Animation child) in a tree.
 *
 * @param {Function} visitor
 * @param {anm.Element} visitor.child
 * @param {Object} [data]
 */
Animation.prototype.each = function(visitor, data) {
    for (var i = 0, tlen = this.tree.length; i &lt; tlen; i++) {
        visitor(this.tree[i], data);
    }
    return this;
};

<span id='anm-Animation-method-iter'>/**
</span> * @method iter
 * @chainable
 *
 * Iterate through every root (direct Animation child) element in a tree.
 *
 * @param {Function} iterator
 * @param {anm.Element} iterator.child
 * @param {Boolean} iterator.return `false`, if this element should be removed
 */
Animation.prototype.iter = function(func, rfunc) {
    iter(this.tree).each(func, rfunc);
    return this;
};

<span id='anm-Animation-method-render'>/**
</span> * @method render
 *
 * Render the Animation for given context at given time.
 *
 * @param {Canvas2DContext} context
 * @param {Number} time
 * @param {Number} [dt] The difference in time between current frame and previous one
 */
Animation.prototype.render = function(ctx, time, dt) {
    ctx.save();
    var zoom = this.zoom;
    if (zoom != 1) {
        ctx.scale(zoom, zoom);
    }
    if (this.bgfill) {
        if (!(this.bgfill instanceof Brush)) this.bgfill = Brush.fill(this.bgfill);
        this.bgfill.apply(ctx);
        ctx.fillRect(0, 0, this.width, this.height);
    }
    this.each(function(child) {
        child.render(ctx, time, dt);
    });
    ctx.restore();
};

<span id='anm-Animation-method-jump'>/**
</span> * @method jump
 *
 * Jump to the given time in animation. Currently calls a {@link anm.Player#seek player.seek} for
 * every Player where this animation was loaded inside.
 *
 * @param {Number} time
 */
Animation.prototype.jump = function(t) {
    utils.keys(this.targets, function(id, player) {
        if (player) player.seek(t);
    });
};

<span id='anm-Animation-method-jumpTo'>/**
</span> * @method jumpTo
 *
 * Jump to the given start time of the element found with passed selector (uses
 * {@link anm.Animation#jumpTo animation.jumpTo} inside)
 *
 * @param {String} selector
 */
Animation.prototype.jumpTo = function(selector) {
    var elm = anim.find(selector);
    if (!elm) return;
    this.jump(elm.gband[0]);
};

// TODO: test
<span id='anm-Animation-method-getFittingDuration'>/**
</span> * @method getFittingDuration
 *
 * Get the duration where all child elements&#39; bands fit.
 *
 * @return {Number} The calculated duration
 */
Animation.prototype.getFittingDuration = function() {
    var max_pos = -Infinity;
    var me = this;
    this.each(function(child) {
        var elm_tpos = child._max_tpos();
        if (elm_tpos &gt; max_pos) max_pos = elm_tpos;
    });
    return max_pos;
};

<span id='anm-Animation-method-reset'>/**
</span> * @method reset
 * @chainable
 *
 * Reset all render-related data for itself, and the data of all the elements.
 */
Animation.prototype.reset = function() {
    this.__informEnabled = true;
    this.each(function(child) {
        child.reset();
    });
    return this;
};

<span id='anm-Animation-method-playedIn'>/**
</span> * @method playedIn
 * @param {anm.Player} player the Player where animation was loaded to
 * @chainable
 *
 * See also {@link anm.Animation#dispose animation.dispose}.
 *
 * Remembers that this Animation is loaded in this Player instance, so
 * passes calls, like time jump requests, to it. Called automatically
 * when Animation was loaded into some Player.
 */
Animation.prototype.playedIn = function(player) {
    this.targets[player.id] = player;
    return this;
}

<span id='anm-Animation-method-dispose'>/**
</span> * @method dispose
 * @param {anm.Player} [player] the Player which disposes this animation.
 * @chainable
 *
 * Remove every possible allocated data to either never use this animation again or
 * start using it from scratch as if it never was used before. If Player instance was
 * passed, Animation also forgets it was played in this Player, so different calls,
 * like time jumps, fired from the Animation won&#39;t be passed to it. Called automatically
 * when Animation needs to be detached from some Player.
 */
Animation.prototype.dispose = function(player) {
    if (player) this.targets[player.id] = null;
    this.disposeHandlers();
    var me = this;
    /* FIXME: unregistering removes from tree, ensure it is safe */
    this.iter(function(child) {
        me._unregister_no_rm(child);
        child.dispose();
        return false;
    });
    return this;
};

<span id='anm-Animation-method-isEmpty'>/**
</span> * @method isEmpty
 *
 * Does Animation has any Elements inside.
 *
 * @return {Boolean} `true` if no Elements, `false` if there are some.
 */
Animation.prototype.isEmpty = function() {
    return this.tree.length === 0;
};

<span id='anm-Animation-method-toString'>/**
</span> * @method toString
 *
 * Get a pretty description of this Animation
 *
 * @return {String} pretty string
 */
Animation.prototype.toString = function() {
    return &quot;[ Animation &quot;+(this.name ? &quot;&#39;&quot;+this.name+&quot;&#39;&quot; : &quot;&quot;)+&quot;]&quot;;
};

<span id='anm-Animation-method-subscribeEvents'>/**
</span> * @method subscribeEvents
 * @private
 *
 * @param {Canvas} canvas
 */
Animation.prototype.subscribeEvents = function(canvas) {
    engine.subscribeAnimationToEvents(canvas, this, DOM_TO_EVT_MAP);
};

<span id='anm-Animation-method-unsubscribeEvents'>/**
</span> * @method unsubscribeEvents
 * @private
 *
 * @param {Canvas} canvas
 */
Animation.prototype.unsubscribeEvents = function(canvas) {
    engine.unsubscribeAnimationFromEvents(canvas, this);
};

Animation.prototype.handle__x = function(type, evt) {
    if (events.mouse(type)) {
        var pos = evt.pos;
        this.each(function(child) {
            child.inside(pos, function(elm) { // filter elements
                return elm.subscribedTo(type);
            }, function(elm, local_pos) { // point is inside
                elm.fire(type, evt);
            });
        });
        return false;
    }
    return true;
};

<span id='anm-Animation-method-addToTree'>/**
</span> * @method addToTree
 * @private
 *
 * @param {anm.Element} element
 */
Animation.prototype.addToTree = function(elm) {
    if (!elm.children) throw errors.animation(ErrLoc.A.OBJECT_IS_NOT_ELEMENT, this);
    this._register(elm);
    /*if (elm.children) this._addElems(elm.children);*/
    this.tree.push(elm);
};

/*Animation.prototype._addElems = function(elems) {
    for (var ei = 0; ei &lt; elems.length; ei++) {
        var _elm = elems[ei];
        this._register(_elm);
    }
}*/
Animation.prototype._register = function(elm) {
    if (this.hash[elm.id]) throw errors.animation(ErrLoc.A.ELEMENT_IS_REGISTERED, this);
    elm.registered = true;
    elm.anim = this;
    this.hash[elm.id] = elm;

    var me = this;

    elm.each(function(child) {
        me._register(child);
    });
};

Animation.prototype._unregister_no_rm = function(elm) {
    this._unregister(elm, true);
};

Animation.prototype._unregister = function(elm, save_in_tree) { // save_in_tree is optional and false by default
    if (!elm.registered) throw errors.animation(ErrLoc.A.ELEMENT_IS_NOT_REGISTERED, this);
    var me = this;
    elm.each(function(child) {
        me._unregister(child);
    });
    var pos = -1;
    if (!save_in_tree) {
      while ((pos = this.tree.indexOf(elm)) &gt;= 0) {
        this.tree.splice(pos, 1); // FIXME: why it does not goes deeply in the tree?
      }
    }
    delete this.hash[elm.id];
    elm.registered = false;
    elm.anim = null;
    //elm.parent = null;
};

Animation.prototype._collectRemoteResources = function(player) {
    var remotes = [],
        anim = this;
    this.traverse(function(elm) {
        if (elm._hasRemoteResources(anim, player)) {
           remotes = remotes.concat(elm._collectRemoteResources(anim, player)/* || []*/);
        }
    });
    if(this.fonts &amp;&amp; this.fonts.length) {
        remotes = remotes.concat(this.fonts.map(function(f){return f.url;}));
    }
    return remotes;
};

Animation.prototype._loadRemoteResources = function(player) {
    var anim = this;
    this.traverse(function(elm) {
        if (elm._hasRemoteResources(anim, player)) {
           elm._loadRemoteResources(anim, player);
        }
    });
    anim.loadFonts(player);
};

<span id='anm-Animation-method-find'>/**
</span> * @method find
 *
 * Searches for an {@link anm.Element element} by name through another {@link anm.Element element}&#39;s
 * children, or through all the elements in the Animation itself, if no other element was provided.
 *
 * NB: `find` method will be improved soon to support special syntax of searching,
 * so you will be able to search almost everything
 *
 * @param {String} name Name of the element(s) to find
 * @param {anm.Element} [where] Where to search elements for; if omitted, searches in Animation
 *
 * @return {anm.Element} First found element
 */
Animation.prototype.find = function(selector, where) {
    return this.findAll(selector, where)[0]; // FIXME: overhead, search for the first one and exit
};

<span id='anm-Animation-method-findAll'>/**
</span> * @method findAll
 *
 * Searches for {@link anm.Element elements} by name through another {@link anm.Element element}&#39;s
 * children, or through all the elements in the Animation itself, if no other element was provided.
 *
 * NB: `findAll` method will be improved soon to support special syntax of searching,
 * so you will be able to search almost everything
 *
 * @param {String} name Name of the element(s) to find
 * @param {anm.Element} [where] Where to search elements for; if omitted, searches in Animation
 *
 * @return {Array} An array of found elements
 */
Animation.prototype.findAll = function(selector, where) {
    where = where || this;
    var name = selector;
    var found = [];
    if (where.name == name) found.push(name);
    where.traverse(function(elm)  {
        if (elm.name == name) found.push(elm);
    });
    return found;
};

<span id='anm-Animation-method-findById'>/**
</span> * @method findById
 *
 * Searches for {@link anm.Element elements} by ID inside another inside the
 * Animation. Actually, just gets it from hash map, so O(1).
 *
 * @param {String} id ID of the element to find
 * @return {anm.Element|Null} An element you&#39;ve searched for, or null
 *
 * @deprecated in favor of special syntax in `find` method
 */
Animation.prototype.findById = function(id) {
    return this.hash[id];
};

/*
 * @method invokeAllLaters
 * @private
 */
Animation.prototype.invokeAllLaters = function() {
    for (var i = 0; i &lt; this._laters.length; i++) {
        this._laters[i].call(this);
    }
};

/*
 * @method clearAllLaters
 * @private
 */
Animation.prototype.clearAllLaters = function() {
    this._laters = [];
};

/*
 * @method invokeLater
 * @private
 */
Animation.prototype.invokeLater = function(f) {
    this._laters.push(f);
};

var FONT_LOAD_TIMEOUT = 10000, //in ms
    https = engine.isHttps;

/*
 * @method loadFonts
 * @private
 */
Animation.prototype.loadFonts = function(player) {
    if (!this.fonts || !this.fonts.length) {
        return;
    }

    var fonts = this.fonts,
        style = engine.createStyle(),
        css = &#39;&#39;,
        fontsToLoad = [],
        detector = new FontDetector();

    for (var i = 0; i &lt; fonts.length; i++) {
        var font = fonts[i];
        if (!font.url || !font.face) {
            //no font name or url
            continue;
        }
        var url = font.url, woff = font.woff;
        if (https) {
            //convert the URLs to https
            url = url.replace(&#39;http:&#39;, &#39;https:&#39;);
            if (woff) {
                woff = woff.replace(&#39;http:&#39;, &#39;https:&#39;);
            }
        }
        fontsToLoad.push(font);
        css += &#39;@font-face {\n&#39; +
            &#39;font-family: &quot;&#39; + font.face + &#39;&quot;;\n&#39; +
            &#39;src:&#39; +  (woff ? &#39; url(&quot;&#39;+woff+&#39;&quot;) format(&quot;woff&quot;),\n&#39; : &#39;&#39;) +
            &#39; url(&quot;&#39;+url+&#39;&quot;) format(&quot;truetype&quot;);\n&#39; +
            (font.style ? &#39;font-style: &#39; + font.style +&#39;;\n&#39; : &#39;&#39;) +
            (font.weight ? &#39;font-weight: &#39; + font.weight + &#39;;\n&#39; : &#39;&#39;) +
            &#39;}\n&#39;;
    }

    if (fontsToLoad.length === 0) {
        return;
    }

    style.innerHTML = css;
    document.head.appendChild(style); // FIXME: should use engine

    var getLoader = function(i) {
            var face = fontsToLoad[i].face;
            return function(success) {
                var interval = 100,
                counter = 0,
                intervalId,
                checkLoaded = function() {
                    counter += interval;
                    var loaded = detector.detect(face);
                    if (loaded || counter &gt; FONT_LOAD_TIMEOUT) {
                        // after 10 seconds, we&#39;ll just assume the font has been loaded
                        // and carry on. this should help when the font could not be
                        // reached for whatever reason.
                        clearInterval(intervalId);
                        success();
                    }
                };
                intervalId = setInterval(checkLoaded, interval);
            };
    };

    for (i = 0; i &lt; fontsToLoad.length; i++) {
        ResMan.loadOrGet(player.id, fontsToLoad[i].url, getLoader(i));
    }

};

module.exports = Animation;
</pre>
</body>
</html>
