<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var conf = require(&#39;../conf.js&#39;),
    log = require(&#39;../log.js&#39;);

var engine = require(&#39;engine&#39;),
    resMan = require(&#39;../resource_manager.js&#39;);

var Bounds = require(&#39;./bounds.js&#39;);

Sheet.instances = 0;
Sheet.MISSED_SIDE = 50;
/* TODO: rename to Static and take optional function as source? */
<span id='anm-Sheet-method-constructor'><span id='anm-Sheet'>/**
</span></span> * @class anm.Sheet
 *
 * Sheet class represent both single image and sprite-sheet. It stores
 * active region, and if its bounds are equal to image size (and they are,
 * by default), then the source is treated as a single image. This active region
 * may be changed dynamically during the animation, and this gives the effect of
 * a spite-sheet.
 *
 * See {@link anm.Element#image Element.image()}
 *
 * @constructor
 *
 * @param {String} src image/spritesheet URL
 * @param {Function} [f] callback to perform when image will be received
 * @param {anm.Sheet} f.this sheet instance
 * @param {Image} f.img corresponding DOM Image element
 * @param {Number} [start_region] an id for initial region
 */
function Sheet(src, callback, start_region) {
    this.id = Sheet.instances++;
    this.src = src;
    this._dimen = /*dimen ||*/ [0, 0];
    this.regions = [ [ 0, 0, 1, 1 ] ]; // for image, sheet contains just one image
    this.regions_f = null;
    // this.aliases = {}; // map of names to regions (or regions ranges)
    /* use state property for region num? or conform with state jumps/positions */
    /* TODO: rename region to frame */
    this.cur_region = start_region || 0; // current region may be changed with modifier
    this.ready = false;
    this.wasError = false;
    this._image = null;
    this._callback = callback;
    this._thumbnail = false; // internal flag, used to load a player thumbnail
};
<span id='anm-Sheet-method-load'>/**
</span> * @private @method load
 */
Sheet.prototype.load = function(player_id, callback, errback) {
    var callback = callback || this._callback;
    if (this._image) throw new Error(&#39;Already loaded&#39;); // just skip loading?
    var me = this;
    if (!me.src) {
        $log.error(&#39;Empty source URL for image&#39;);
        me.ready = true; me.wasError = true;
        if (errback) errback.call(me, &#39;Empty source&#39;);
        return;
    }
    resMan.loadOrGet(player_id, me.src,
        function(notify_success, notify_error) { // loader
            if (!me._thumbnail &amp;&amp; conf.doNotLoadImages) {
              notify_error(&#39;Loading images is turned off&#39;);
              return; }
            var img = new Image();
            var props = engine.getAnmProps(img);
            img.onload = img.onreadystatechange = function() {
                if (props.ready) return;
                if (this.readyState &amp;&amp; (this.readyState !== &#39;complete&#39;)) {
                    notify_error(this.readyState);
                }
                props.ready = true; // this flag is to check later if request succeeded
                // this flag is browser internal
                img.isReady = true; /* FIXME: use &#39;image.complete&#39; and
                                      &#39;...&#39; (network exist) combination,
                                      &#39;complete&#39; fails on Firefox */
                notify_success(img);
            };
            img.onerror = notify_error;
            img.addEventListener(&#39;error&#39;, notify_error, false);
            try { img.src = me.src; }
            catch(e) { notify_error(e); }
        },
        function(image) {  // oncomplete
            me._image = image;
            me._dimen = [ image.width, image.height ];
            me.ready = true; // this flag is for users of the Sheet class
            if (callback) callback.call(me, image);
        },
        function(err) { log.error(err.srcElement || err.path, err.message || err);
                        me.ready = true;
                        me.wasError = true;
                        if (errback) errback.call(me, err); });
};
<span id='anm-Sheet-method-updateRegion'>/**
</span> * @private @method updateRegion
 */
Sheet.prototype.updateRegion = function() {
    if (this.cur_region &lt; 0) return;
    var region;
    if (this.region_f) { region = this.region_f(this.cur_region); }
    else {
        var r = this.regions[this.cur_region],
            d = this._dimen;
        region = [ r[0] * d[0], r[1] * d[1],
                   r[2] * d[0], r[3] * d[1] ];
    }
    this.region = region;
};
<span id='anm-Sheet-method-apply'>/**
</span> * @private @method apply
 */
Sheet.prototype.apply = function(ctx/*, fill, stroke, shadow*/) {
    if (!this.ready) return;

    if (this.wasError) { this.applyMissed(ctx); return; }
    this.updateRegion();
    var region = this.region;
    ctx.drawImage(this._image, region[0], region[1],
                               region[2], region[3], 0, 0, region[2], region[3]);
};
<span id='anm-Sheet-method-applyMissed'>/**
</span> * @private @method applyMissed
 *
 * If there was an error in process of receiving an image, the &quot;missing&quot; image is
 * displayed, this method draws it in context.
 */
Sheet.prototype.applyMissed = function(ctx) {
    ctx.save();
    ctx.strokeStyle = &#39;#900&#39;;
    ctx.lineWidth = 1;
    ctx.beginPath();
    var side = Sheet.MISSED_SIDE;
    ctx.moveTo(0, 0);
    ctx.lineTo(side, 0);
    ctx.lineTo(0, side);
    ctx.lineTo(side, side);
    ctx.lineTo(0, 0);
    ctx.lineTo(0, side);
    ctx.lineTo(side, 0);
    ctx.lineTo(side, side);
    ctx.stroke();
    ctx.restore();
};
Sheet.MISSED_BOUNDS = new Bounds(0, 0, Sheet.MISSED_SIDE, Sheet.MISSED_SIDE);
<span id='anm-Sheet-method-bounds'>/**
</span> * @method bounds
 *
 * Get image bounds
 *
 * @return anm.Bounds bounds
 */
Sheet.prototype.bounds = function() {
    if (this.wasError) return Sheet.MISSED_BOUNDS;
    // TODO: when using current_region, bounds will depend on that region
    if (!this.ready) return Bounds.NONE;
    if(!this.region) {
      this.updateRegion();
    }
    var r = this.region;
    return new Bounds(0, 0, r[2], r[3]);
}
<span id='anm-Sheet-method-clone'>/**
</span> * @method clone
 *
 * Clone this image
 *
 * @return anm.Sheet clone
 */
Sheet.prototype.clone = function() {
    // FIXME: fix for sprite-sheet
    return new Sheet(this.src);
};

Sheet.prototype.invalidate = function() {
};
Sheet.prototype.reset = function() { };
Sheet.prototype.dispose = function() {
};

// TODO: Bring back Sprite-animator
// https://github.com/Animatron/player/blob/3903d59c7653ec6a0dcc578d6193e6bdece4a3a0/src/builder.js#L213
// https://github.com/Animatron/player/blob/3903d59c7653ec6a0dcc578d6193e6bdece4a3a0/src/builder.js#L926

module.exports = Sheet;
</pre>
</body>
</html>
