<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var C = require(&#39;./constants.js&#39;);

var errors = require(&#39;./errors.js&#39;);

// Events
// -----------------------------------------------------------------------------
function registerEvent(id, name) { C[id] = name; }

// TODO: use EventEmitter
// FIXME: all errors below were AnimErr instances

// adds specified events support to the `subj` object. `subj` object receives
// `handlers` property that keeps the listeners for each event. Also, it gets
// `e_&lt;evt_name&gt;` function for every event provided to call it when it is
// required to call all handlers of all of thise event name
// (`fire(&#39;&lt;evt_name&gt;&#39;, ...)` is the same but can not be reassigned by user).
// `subj` can define `handle_&lt;evt_name&gt;` function to handle concrete event itself,
// but without messing with other handlers.
// And, user gets `on` function to subcribe to events and `provides` to check
// if it is allowed.
function provideEvents(subj, events) {
    subj.prototype._initHandlers = (function(evts) { // FIXME: make automatic
        return function() {
            var _hdls = {};
            this.handlers = _hdls;
            for (var ei = 0, el = evts.length; ei &lt; el; ei++) {
                _hdls[evts[ei]] = [];
            }
        };
    })(events);
    subj.prototype.on = function(event, handler) {
        if (!this.handlers) throw errors.system(&#39;Instance is not initialized with handlers, call __initHandlers in its constructor&#39;);
        if (!this.provides(event)) throw errors.system(&#39;Event \&#39;&#39; + event +
                                                 &#39;\&#39; is not provided by &#39; + this);
        if (!handler) return;
        this.handlers[event].push(handler);
        // FIXME: make it chainable, use handler instance to unbind, instead of index
        return (this.handlers[event].length - 1);
    };
    subj.prototype.subscribedTo = function(event) {
        return this.handlers &amp;&amp; this.handlers[event] &amp;&amp; this.handlers[event].length;
    };
    subj.prototype.fire = function(event/*, evt_args*/) {
        if (this.disabled) return;
        if (!this.handlers) throw errors.system(&#39;Instance is not initialized with handlers, call __initHandlers in its constructor&#39;);
        if (!this.provides(event)) throw errors.system(&#39;Event \&#39;&#39; + event +
                                                 &#39;\&#39; is not provided by &#39; + this);
        if (this.filterEvent &amp;&amp; !(this.filterEvent.apply(this, arguments))) return;
        if (this[&#39;handle_&#39;+event] || this.handlers[event].length) {
            var evt_args = new Array(arguments.length - 1);
            for (var i = 1; i &lt; arguments.length; i++) {
                evt_args[i - 1] = arguments[i];
            }
            if (this[&#39;handle_&#39;+event]) this[&#39;handle_&#39;+event].apply(this, evt_args);
            var _hdls = this.handlers[event];
            for (var hi = 0, hl = _hdls.length; hi &lt; hl; hi++) {
                _hdls[hi].apply(this, evt_args);
            }
        }

    };
    subj.prototype.provides = (function(evts) {
        return function(event) {
            if (!this.handlers) throw errors.system(&#39;Instance is not initialized with handlers, call __initHandlers in its constructor&#39;);
            if (!event) return evts;
            return this.handlers.hasOwnProperty(event);
        };
    })(events);
    subj.prototype.unbind = function(event, idx) {
        if (!this.handlers) throw errors.system(&#39;Instance is not initialized with handlers, call __initHandlers in its constructor&#39;);
        if (!this.provides(event)) return;
        if (this.handlers[event][idx]) {
            this.handlers[event].splice(idx, 1);
        }
    };
    subj.prototype.disposeHandlers = function() {
        if (!this.handlers) throw errors.system(&#39;Instance is not initialized with handlers, call __initHandlers in its constructor&#39;);
        var _hdls = this.handlers;
        for (var evt in _hdls) {
            if (_hdls.hasOwnProperty(evt)) _hdls[evt] = [];
        }
    };
    /* FIXME: call fire/e_-funcs only from inside of their providers, */
    /* TODO: wrap them with event objects */
    var makeFireFunc = function(event) {
        return function(evtobj) {
            this.fire(event, evtobj);
        };
    };

    for (var ei = 0, el = events.length; ei &lt; el; ei++) {
        subj.prototype[&#39;e_&#39;+events[ei]] = makeFireFunc(events[ei]);
    }
}

registerEvent(&#39;S_NEW_PLAYER&#39;, &#39;new&#39;);
registerEvent(&#39;S_PLAYER_DETACH&#39;, &#39;detach&#39;);

// ### Events
/* ---------- */

// NB: All of the events must have different values, or the flow will be broken
// FIXME: allow grouping events, i.e. value may a group_marker + name of an event
//        also, allow events to belong to several groups

// * mouse
registerEvent(&#39;X_MCLICK&#39;, &#39;mouseclick&#39;);
registerEvent(&#39;X_MDCLICK&#39;, &#39;mousedoubleclick&#39;);
registerEvent(&#39;X_MUP&#39;, &#39;mouseup&#39;);
registerEvent(&#39;X_MDOWN&#39;, &#39;mousedown&#39;);
registerEvent(&#39;X_MMOVE&#39;, &#39;mousemove&#39;);
registerEvent(&#39;X_MOVER&#39;, &#39;mouseover&#39;);
registerEvent(&#39;X_MOUT&#39;, &#39;mouseout&#39;);

// * keyboard
registerEvent(&#39;X_KPRESS&#39;, &#39;keypress&#39;);
registerEvent(&#39;X_KUP&#39;, &#39;keyup&#39;);
registerEvent(&#39;X_KDOWN&#39;, &#39;keydown&#39;);

// * bands
registerEvent(&#39;X_START&#39;, &#39;bandstart&#39;);
registerEvent(&#39;X_STOP&#39;, &#39;bandstop&#39;);

// * Animation or Element error
registerEvent(&#39;X_ERROR&#39;, &#39;error&#39;);

// * animation start/stop
registerEvent(&#39;A_START&#39;, &#39;animationstart&#39;);
registerEvent(&#39;A_STOP&#39;, &#39;animationstop&#39;);
registerEvent(&#39;A_PAUSE&#39;, &#39;animationpause&#39;);

// * playing (player state)

registerEvent(&#39;S_CHANGE_STATE&#39;, &#39;statechange&#39;);
registerEvent(&#39;S_PLAY&#39;, &#39;play&#39;);
registerEvent(&#39;S_PAUSE&#39;, &#39;pause&#39;);
registerEvent(&#39;S_STOP&#39;, &#39;stop&#39;);
registerEvent(&#39;S_COMPLETE&#39;, &#39;complete&#39;);
registerEvent(&#39;S_REPEAT&#39;, &#39;repeat&#39;);
registerEvent(&#39;S_IMPORT&#39;, &#39;import&#39;);
registerEvent(&#39;S_LOAD&#39;, &#39;load&#39;);
registerEvent(&#39;S_RES_LOAD&#39;, &#39;loadresources&#39;);
registerEvent(&#39;S_LOADING_PROGRESS&#39;, &#39;loadprogress&#39;);
registerEvent(&#39;S_TIME_UPDATE&#39;, &#39;timeupdate&#39;);
registerEvent(&#39;S_ERROR&#39;, &#39;error&#39;); // is not intersecting with X_ERROR, so it is safe
                                   // they have same name

function isMouseEvent(type) { return (type.indexOf(&#39;mouse&#39;) === 0); }
function isKeyboardEvent(type) { return (type.indexOf(&#39;key&#39;) === 0); }
function isMouseOrKeyboardEvent(type) { return isMouseEvent(type) || isKeyboardEvent(type); }

var m_and_k = {
    &#39;mouseclick&#39;: 1,
    &#39;mousedoubleclick&#39;: 2,
    &#39;mouseup&#39;: 4,
    &#39;mousedown&#39;: 8,
    &#39;mousemove&#39;: 16,
    &#39;mouseover&#39;: 32,
    &#39;mouseout&#39;: 64,
    &#39;keypress&#39;: 128,
    &#39;keyup&#39;: 256,
    &#39;keydown&#39;: 512
};

function EventState() { this.reset(); }
EventState.prototype.reset = function() { this.state = 0; }
EventState.prototype.save = function(type) { this.state = this.state | m_and_k[type]; }
EventState.prototype.check = function(type) { return this.state &amp; m_and_k[type]; }

module.exports = {
    mouse: isMouseEvent,
    keyboard: isKeyboardEvent,
    mouseOrKeyboard: isMouseOrKeyboardEvent,
    registerEvent: registerEvent,
    provideEvents: provideEvents,
    EventState: EventState
};
</pre>
</body>
</html>
