<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * Copyright (c) 2011-@COPYRIGHT_YEAR by Animatron.
 * All rights are reserved.
 *
 * Animatron Player is licensed under the MIT License, see LICENSE.
 *
 * @VERSION
 */

// see ./animatron-project-@VERSION.orderly for a readable scheme of accepted project

// This importer imports only the full (a.k.a. intact) format of scenes
// (where all elements are objects of objects)

var AnimatronIntactImporter = (function() {

var IMPORTER_ID = &#39;ANM_INTACT&#39;;

function __MYSELF() { }

var C = anm.constants,
    Animation = anm.Animation,
    Element = anm.Element,
    Path = anm.Path,
    Text = anm.Text,
    Bands = anm.Bands,
    test = anm._valcheck;

anm.importers[IMPORTER_ID] = {};

// ** META / PARAMS **

__MYSELF.prototype.configureMeta = function(prj) {
    // ( id, name, author, copyright, version, description, modificationTime, numberOfScenes )
    var _m = prj.meta;
    return {
        &#39;title&#39;: _m.name,
        &#39;author&#39;: _m.author,
        &#39;copyright&#39;: _m.copyright,
        &#39;version&#39;: _m.version,
        &#39;description&#39;: _m.description,
        &#39;duration&#39;: _m.duration
    };
};
__MYSELF.prototype.configureAnim = function(prj) {
    // ( framerate, dimension, background, duration,
    //   elements, scenes )
    var _a = prj.anim;
    return {
        &#39;fps&#39;: _a.framerate,
        &#39;width&#39;: _a.dimension ? Math.floor(_a.dimension[0]) : undefined,
        &#39;height&#39;: _a.dimension ? Math.floor(_a.dimension[1]): undefined,
        &#39;bgfill&#39;: _a.background ? Convert.fill(_a.background) : null,
    }
}

// ** PROJECT **

__MYSELF.prototype.load = function(prj) {
    // ( framerate, dimension, background, duration,
    //   elements, scenes )
    //if (window &amp;&amp; window.console &amp;&amp; window.__anm_conf &amp;&amp; window.__anm_conf.logImport) console.log(prj);
    if (console &amp;&amp; (typeof __anm_conf !== &#39;undefined&#39;) &amp;&amp; __anm_conf.logImport) console.log(prj);
    if (typeof __anm !== &#39;undefined&#39;) __anm.lastImportedProject = prj;
    // FIXME: allow importing several scenes
    var anim =  this.importAnimation(prj.anim.scenes[0],
                                     prj.anim.elements);
    if (prj.meta.duration != undefined) anim.setDuration(prj.meta.duration);
    if (prj.anim.background) anim.bgfill = Convert.fill(prj.anim.background);
    return anim;
};

// ** ELEMENTS **

__MYSELF.prototype.importAnimation = function(scene_id, source) {
    var anim = new Animation();
    var node = this.findNode(scene_id, source);
    if (!node) throw new Error(&quot;Scene was not found by ID&quot;);
    if (extract_type(node.id) != TYPE_SCENE) throw new Error(&quot;Given Scene ID points to something else&quot;);
    anim.add(this.convertNode(node, source));
    return anim;
}

var TYPE_UNKNOWN = &quot;00&quot;,
    TYPE_CLIP    = &quot;01&quot;,
    TYPE_SCENE   = &quot;02&quot;,
    TYPE_PATH    = &quot;03&quot;,
    TYPE_TEXT    = &quot;04&quot;,
    TYPE_RECT    = &quot;05&quot;,
    TYPE_OVAL    = &quot;06&quot;,
    TYPE_PENCIL  = &quot;07&quot;,
    TYPE_IMAGE   = &quot;08&quot;,
    TYPE_GROUP   = &quot;09&quot;,
    TYPE_BRUSH   = &quot;0a&quot;,
    TYPE_STAR    = &quot;0b&quot;,
    TYPE_POLYGON = &quot;0c&quot;,
    TYPE_CURVE   = &quot;0d&quot;,
    TYPE_AUDIO   = &quot;0e&quot;,
    TYPE_LINE    = &quot;0f&quot;;

__MYSELF.prototype.convertNode = function(src, all) {
//__MYSELF.prototype.importElement = function(trg, src, in_band) {
    var trg;
    var type = extract_type(src.id);
    // TODO: move to Converters object?
    // if a node is a group type
    if ((type == TYPE_CLIP) || (type == TYPE_GROUP) || (type == TYPE_SCENE)) {
        trg = new Element();
        trg.name = src.name;
        // iterate through the layers
        var _layers = src.layers,
            _layers_targets = [];
        // in Animatron. layers are in reverse order
        for (var li = _layers.length; li--;) {
            var lsrc = _layers[li],
                ltype = extract_type(lsrc.eid);
            // recursively check if layer element is a group or not and return the element
            var ltrg = this.convertNode(this.findNode(lsrc.eid, all), all);
            if (!ltrg.name) { ltrg.name = lsrc.name; }
            // transfer layer data from the layer source into the
            // target — contains bands, tweens and pivot
            this._transferLayerData(lsrc, ltrg, trg.gband, ltype);
            if (!lsrc.masked) {
                // layer is a normal one
                trg.add(ltrg);
                _layers_targets.push(ltrg);
            } else {
                // layer is a mask, apply it to the required number
                // of previously collected layers
                var mask = ltrg,
                    maskedToGo = lsrc.masked, // layers below to apply mask
                    ltl = _layers_targets.length;
                if (maskedToGo &gt; ltl) {
                    throw new Error(&#39;No layers collected to apply mask&#39;)
                };
                while (maskedToGo) {
                    var masked = _layers_targets[ltl-maskedToGo];
                    //console.log(mask.name + &#39;-&gt;&#39; + masked.name);
                    masked.setMask(mask);
                    maskedToGo--;
                }
            }
        }
        // transfer repetition data from the source layer
        // into the target (incl. end or on-end action)
        this._transferRepetitionData(src, trg);
    } else if
      ((type != TYPE_UNKNOWN)
      /*(type == TYPE_PATH)  || (type == TYPE_TEXT)   || (type == TYPE_RECT)    ||
        (type == TYPE_OVAL)  || (type == TYPE_PENCIL) || (type == TYPE_IMAGE)   ||
        (type == TYPE_BRUSH) || (type == TYPE_STAR)   || (type == TYPE_POLYGON) ||
        (type == TYPE_CURVE) || (type == AUDIO)       || (type == LINE)*/) {
        trg = new Element();
        trg.name = src.name;
        // transfer shape data from the source into the
        // target — contains either path, text or image
        this._transferShapeData(src, trg, type);
        // FIXME: fire an event instead (event should inform about type of the importer)
        if (trg.importCustomData) trg.importCustomData(src, type, IMPORTER_ID);
    }
    /*if (trg &amp;&amp;
        (trg.mode != C.R_ONCE) &amp;&amp;
        (trg.children.length &gt; 0) &amp;&amp;
        (!test.finite(trg.gband[1]))) {
        trg.makeBandFit();
    }*/
    return trg;
}
__MYSELF.prototype.findNode = function(id, source) {
    for (var i = 0; i &lt; source.length; i++) {
        if (source[i].id === id) return source[i];
    }
    throw new Error(&quot;Node with id &quot; + id + &quot; was not found in passed source&quot;);
}
__MYSELF.prototype._transferShapeData = function(src, trg, type) {
    if (src.url &amp;&amp; (type == TYPE_IMAGE)) trg.image = Convert.sheet(src.url, src.size);
    if (src.path) trg.path = Convert.path(src.path, src.fill, src.stroke, src.shadow);
    if (src.text) trg.text = Convert.text(src.text, src.font,
                                          src.fill, src.stroke, src.shadow);
}
// collect required data from source layer
__MYSELF.prototype._transferLayerData = function(src, trg, in_band, type) {
    if (src.visible === false) trg.disabled = true; // to.visible = false;
    if (type == TYPE_GROUP) {
        trg.gband = [ 0, src.band[1] ];
        trg.lband = [ 0, src.band[1] ];
        // trg.gband = Convert.band(src.band);
        // trg.lband = [ trg.gband[0] - in_band[0],
        //               trg.gband[1] - in_band[0] ];
    } else {
        trg.lband = Convert.band(src.band);
        trg.gband = in_band ? Bands.wrap(in_band, trg.lband)
                            : trg.lband;
    }
    trg.pvt = [ 0, 0 ];
    trg.reg = src.reg || [ 0, 0 ];
    if (src.tweens) {
        var translate;
        for (var tweens = src.tweens, ti = 0, tl = tweens.length;
             ti &lt; tl; ti++) {
            if (tweens[ti].type == &#39;Translate&#39;) translate = tweens[ti];
            trg.addTween(Convert.tween(tweens[ti]));
        }
        if (translate &amp;&amp; src[&#39;rotate-to-path&#39;]) {
            trg.addTween({
                type: C.T_ROT_TO_PATH,
                band: translate.band
            });
        }
    }
};
__MYSELF.prototype._transferRepetitionData = function(src, trg) {
    // &#39;on-end&#39; is the old-style end, &#39;end&#39; is the current-style
    trg.mode = src[&#39;end&#39;] ? Convert.mode(src[&#39;end&#39;].type)
                          : Convert.oldschool_mode(src[&#39;on-end&#39;]);
    trg.nrep = (src[&#39;end&#39;] &amp;&amp; (src[&#39;end&#39;].counter !== undefined))
                             ? src[&#39;end&#39;].counter : Infinity;

    if (src[&#39;end&#39;] &amp;&amp; (trg.mode == C.R_LOOP)) {
        trg.traverse(function(child) {
            child.mode = C.R_LOOP;
        });
    }
};

// ** CONVERTION **

function extract_type(id) {
    if (id.length !== 24) throw new Error(&#39;Invalid element id &#39; + id);
    return id.substring(id.length - 2);
}

var Convert = {}
Convert.tween = function(tween) {
    // (type, band, path?, easing?)
    var _t = tween,
        _type = Convert.tweenType(_t.type);

    return {
        &#39;band&#39;: _t.band,
        &#39;type&#39;: _type,
        &#39;data&#39;: Convert.tweenData(_type, _t),
        &#39;easing&#39;: Convert.easing(_t.easing)
    };
};
Convert.tweenType = function(from) {
    if (!from) return null;
    if (from === &#39;Rotate&#39;) return C.T_ROTATE;
    if (from === &#39;Translate&#39;) return C.T_TRANSLATE;
    if (from === &#39;Alpha&#39;) return C.T_ALPHA;
    if (from === &#39;Scale&#39;) return C.T_SCALE;
    if (from === &#39;rotate-to-path&#39;) return C.T_ROT_TO_PATH;
    if (from === &#39;Shear&#39;) return C.T_SHEAR;
}
Convert.tweenData = function(type, tween) {
    var data = tween.data;
    if (!data) {
        if (tween.path) return new Path(tween.path);
        return null;
    }
    if ((type === C.T_ROTATE) || (type === C.T_ALPHA)) {
        if (data.length == 2) return data;
        if (data.length == 1) return [ data[0], data[0] ];
    }
    if ((type === C.T_SCALE) || (type === C.T_SHEAR)) {
        if (data.length == 4) return [ [ data[0], data[1] ],
                                       [ data[2], data[3] ] ];
        if (data.length == 2) return [ [ data[0], data[1] ],
                                       [ data[0], data[1] ] ];
        if (data.length == 1) return [ [ data[0], data[0] ],
                                       [ data[0], data[0] ] ];
    }
    return data;
}
Convert.path = function(pathStr, fill, stroke, shadow) {
    // ()
    return new Path(pathStr,
                    Convert.fill(fill),
                    Convert.stroke(stroke),
                    Convert.shadow(shadow));
}
Convert.text = function(lines, font,
                        fill, stroke, shadow) {
    // (lines, font, stroke, fill)
    return new Text(lines, font,
                    Convert.fill(fill),
                    Convert.stroke(stroke),
                    Convert.shadow(shadow));
}
Convert.sheet = function(url, size) {
    var sheet = new anm.Sheet(url);
    sheet._dimen = size;
    return sheet;
}
Convert.shadow = function(src) {
  if (!src || src.offsetX == undefined) return null;
  var shadow = {};
  shadow.color = src.paint.rgba || src.paint.color;
  shadow.offsetX = src.offsetX;
  shadow.offsetY = src.offsetY;
  shadow.blurRadius = src.blur;
  return shadow;
};
Convert.easing = function(from) {
    // (name, path?)
    if (!from) return null;
    return {
          type: Convert.easingType(from.name),
          data: from.path ? (new Path(&#39;M0 0 &#39; + from.path + &#39; Z&#39;)) : null
        };
}
Convert.easingType = function(from) {
    if (!from) return null;
    if (from === &#39;Unknown&#39;) return C.E_PATH;
    if (from === &#39;Default&#39;) return C.E_DEF;
    if (from === &#39;Ease In&#39;) return C.E_IN;
    if (from === &#39;Ease Out&#39;) return C.E_OUT;
    if (from === &#39;Ease In Out&#39;) return C.E_INOUT;
}
Convert.stroke = function(stroke) {
    // (width, paint (color | colors | rgba | rgbas | r0, r1),
    // cap, join, limit)
    if (!stroke) return stroke;
    var brush = {};
    brush.width = stroke.width;
    brush.cap = stroke.cap;
    brush.join = stroke.join;
    if (stroke.paint) {
        var paint = stroke.paint;
        if (paint.rgba || paint.color) {
            brush.color = paint.rgba || paint.color;
        } else if ((typeof paint.r0 !== &#39;undefined&#39;)
                &amp;&amp; (typeof paint.r1 !== &#39;undefined&#39;)) {
            brush.rgrad = Convert.gradient(paint);
        } else if (stroke.paint.colors) {
            brush.lgrad = Convert.gradient(paint);
        }
    }
    return brush;
}
Convert.fill = function(fill) {
    // (color | colors | rgba | rgbas | r0, r1)
    if (!fill) return null;
    var brush = {};
    if (!fill) {
        brush.color = &quot;rgba(0,0,0,0)&quot;;
    } else if (fill.rgba || fill.color) {
        brush.color = fill.rgba || fill.color;
    } else if ((typeof fill.r0 !== &#39;undefined&#39;)
            &amp;&amp; (typeof fill.r1 !== &#39;undefined&#39;)) {
        brush.rgrad = Convert.gradient(fill);
    } else if (fill.rgbas || fill.colors) {
        brush.lgrad = Convert.gradient(fill);
    }
    return brush;
}
Convert.gradient = function(src) {
    // (bounds, offsets, colors, x1, y1, r0?, r1?, alpha)
    var stops = [],
        offsets = src.offsets;
    for (var i = 0; i &lt; offsets.length; i++) {
        stops.push([
            offsets[i],
            src.rgbas ? src.rgbas[i]
                     : src.colors[i]
        ]);
    }
    return {
        r: (typeof src.r0 !== &#39;undefined&#39;) ? [ src.r0, src.r1 ] : null,
        dir: [ [ src.x0, src.y0 ], [ src.x1, src.y1 ] ],
        stops: stops,
        bounds: src.bounds
    };
}
Convert.band = function(from) {
    if (!from) return [ 0, Infinity ];
    if (from.length == 2) return from;
    if (from.length == 1) return [ from[0], Infinity ];
    return [ 0, Infinity ];
}
Convert.mode = function(from) {
    if (!from) return C.R_ONCE;
    if (from === &quot;once&quot;) return C.R_ONCE;
    if (from === &quot;stay&quot;) return C.R_STAY;
    if (from === &quot;loop&quot;) return C.R_LOOP;
    if (from === &quot;bounce&quot;) return C.R_BOUNCE; // FIXME: last is not for sure
}
Convert.oldschool_mode = function(from) {
    if (!from) return C.R_ONCE;
    if (from === &quot;STOP&quot;) return C.R_ONCE;
    if (from === &quot;LOOP&quot;) return C.R_LOOP;
    if (from === &quot;BOUNCE&quot;) return C.R_BOUNCE; // FIXME: last is not for sure
}

return __MYSELF;

})();
</pre>
</body>
</html>
